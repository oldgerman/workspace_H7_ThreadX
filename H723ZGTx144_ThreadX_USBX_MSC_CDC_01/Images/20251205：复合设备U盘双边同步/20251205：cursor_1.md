# (1) 你好，请问你在线吗
_Exported on 12/5/2025 at 19:26:05 GMT+8 from Cursor (2.1.48)_

---

**User**

你好，请问你在线吗

---

**Cursor**

你好，我在。  
可以跟我说说你现在在调试或开发什么，我来帮你一起看看。

---

**User**

你好，请问你是什么AI，介绍一下自己

---

**Cursor**

你好，我是一个集成在 Cursor 里的 **AI 编程助手**，底层是 GPT-5.1 模型，主要帮你做这些事情：

- **看代码 / 查问题**：帮你阅读、分析你工程里的 C/C++、Python、嵌入式代码等，定位 bug、解释函数逻辑。  
- **写代码 / 改代码**：按你的需求直接在项目里新增或修改文件，而不是只给你“参考代码”。  
- **查文档 / 查资料**：对一些和 STM32、ThreadX、USBX、FileX 相关的概念或用法，我可以结合已有知识帮你梳理。  
- **调试思路建议**：比如 SD 卡挂载失败、USB 设备枚举异常、线程/中断问题，我可以帮你规划排查步骤和改动点。

你现在这个工程是 H723 + ThreadX + USBX + FileX 的工程，如果你愿意，可以先告诉我：  
你目前最头疼的是哪一块？比如 SD 卡 `fx_media_open` 失败、USB MSC/CDC 组合设备不好用，还是别的？我可以从这个点开始帮你分析。

---

**User**

目前  threadX Filex+ SD卡 + USBX 实现MSC设备 同时与 USBX CDC ACM 组成USB2.0高速复合设备，使用电脑向 USBX 虚拟串口发送 FileX 读写 64G SD卡测试命令$TEST_SD_SPEED，系统能解析几何到该命令@USBX/App/ascii_protocol.cpp:281-284 ，但 FileX 读写测试函数在 fx_media_open 返回 0x90  无法继续进行 SD卡读写测试@APP/app_demo_sd_filex.c:661-668 ，但电脑是可以看到 USBX MSC的59.4G这个U盘，可对U盘进行文件读写，并且点击U盘的视频文件可以播放和快进，同时USBX 虚拟串口也可以以10ms的频率对电脑下发的命令进行解析回复，我搜索网络上 FlieX 与 USBX MSC一起使用时的帖子找到 https://learn.microsoft.com/en-us/answers/questions/5585847/usbx-msc-lvlx-usbd-storage-write-and-usbd-storage 里面微软工程师说 

> 设备的**唯一**`USBD_STORAGE_Read`功能是通过和提供原始块级访问`USBD_STORAGE_Write`。您不能（也绝对不能）同时在设备上使用 FileX，因为这两个文件系统会立即相互损坏。如果您需要预先将文件加载到磁盘上，则必须：
>
> 1. 请先实现您的 FileX 代码。
> 2. 在“首次启动”例程中，使用 FileX 打开介质，对其进行格式化，创建一个文件，向其中写入数据，然后关闭介质。
> 3. 然后，取消初始化 FileX 并启动 USBX MSC 类，将控制权移交给主机。

然后我明白了FIleX fx_media_open() 与 USBX MSC 线程

@ux_device_class_storage_entry.c (83) 对SD卡 文件系统的会有控制权争夺的问题

那么我应该如何在
@app_demo_sd_filex.c (643) 对SD卡进行读写测试时，将USBX MSC暂时取消注册？（不知”注册“的表述正不正确），然后等fxSdTestSpeed()测试完毕后，再重新挂载 USBX MSC（不知”挂载“的表述正不正确）？是不是可以使用 @ux_device_class_storage_uninitialize.c (84) 来取消挂载？之后该如何重新挂载呢？

---

**Cursor**

## 暂停 MSC 再做 FileX 测试的思路

- `fx_media_open` 在 `fxSdTestSpeed()` 里返回 `0x90`（`FX_MEDIA_NOT_OPEN`），是因为此时 SD 仍被 USBX MSC 的块驱动持有，两个文件系统（PC 端 + 本地 FileX）同时访问同一介质，会互相破坏，这正是你在微软论坛里看到的限制  
```661:668:APP/app_demo_sd_filex.c
status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));
if (status != FX_SUCCESS)
{
    printf("挂载文件系统失败 -- %d\r\n", status);
    return;
}
```

- 当前 MSC 类直接通过 `HAL_SD_ReadBlocks_DMA/HAL_SD_WriteBlocks_DMA` 访问 SD 卡  
```113:213:USBX/App/ux_device_msc.c
status =  HAL_SD_ReadBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);
...
status = HAL_SD_WriteBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);
```
  只要主机保持挂载，USBX 线程就会持续抢占 SD 资源，所以 FileX 无法再次初始化同一介质。

### 推荐的控制流程

1. **建立互斥**：为 SD 驱动创建一个全局 `TX_MUTEX sd_media_lock`；`USBD_STORAGE_Read/Write` 以及你要调用的 FileX 读写函数都必须先 `tx_mutex_get(&sd_media_lock, TX_WAIT_FOREVER)`，结束后释放。这保证在我们主动下线 MSC 之前不会再有新的主机访问。

2. **下线 MSC**（可包装成 `msc_detach()`）：
   - `tx_mutex_get(&sd_media_lock, TX_WAIT_FOREVER)`；
   - `ux_device_stack_disconnect();` 让 USB 设备端主动从总线脱离，PC 会立即看到 U 盘拔出；
   - `ux_device_stack_class_unregister(_ux_system_slave_class_storage_name, ux_device_class_storage_entry);` 这一调用内部就会触发 `ux_device_class_storage_uninitialize()`，释放 MSC 线程和缓冲区（正是你在 `ux_device_class_storage_uninitialize.c` 看到的函数）；
   - 标记 `msc_online = UX_FALSE`。

3. **执行 FileX 测试**：
   - 现在 `fx_media_open()` 可以顺利打开，因为没有其它 FileX 或块驱动持有介质；
   - 完成读写、测速之后，务必 `fx_media_flush()`、`fx_media_close()`。

4. **重新上线 MSC**（可包装成 `msc_attach()`）：
   - 使用启动时保存的 `storage_parameter`、`storage_configuration_number`、`storage_interface_number` 调回 `ux_device_stack_class_register(...)`；
   - `ux_device_stack_connect();` 或调用 `HAL_PCD_Start()` 让设备重新连接主机；PC 会重新枚举出你的 MSC；
   - 释放 `sd_media_lock`，`msc_online = UX_TRUE`。

5. **CDC 命令交互**：在执行 `$TEST_SD_SPEED` 前，通过 CDC 回复 “即将断开 MSC，完成后自动恢复”，测试完成后再通知用户“MSC 已重新枚举”，避免主机端正在读写时丢数据。

### 实际落地建议

- 在 `app_usbx_device.c` 里保存注册 MSC 时的参数，并提供两个 API：`USBX_MSC_Pause()` 与 `USBX_MSC_Resume()`，供 `fxSdTestSpeed()` 调用。  
- `USBD_STORAGE_Read/Write` 的最外层加互斥锁，如果 `msc_online == UX_FALSE` 则直接返回 `UX_ERROR`（主机会得到 I/O 错误，直到你恢复 MSC）。  
- `fxSdTestSpeed()` 流程伪代码：  
```c
void fxSdTestSpeed(void)
{
    USBX_MSC_Pause();
    if (fx_media_open(... ) == FX_SUCCESS) {
        /* 做测速 */
        fx_media_close(&sdio_disk);
    }
    USBX_MSC_Resume();
}
```
- 如果担心频繁重枚举影响 PC 端，可以在 CDC 命令协议中要求主机先“弹出 U 盘”后再发测速命令，这样 MSC 在 `USBD_STORAGE_Deactivate()` 时就能更优雅地下线。

### 重要注意事项

- 切勿让 FileX 与主机同时写同一张卡，否则极易造成 FAT 破坏。
- 重新注册后，PC 看到的是一次全新的 U 盘插入，缓存会被刷新，文件系统一致性才能保证。
- 如果测速只需要裸扇区读写，也可以写一个“原始块测试函数”，直接复用 `HAL_SD_*`，那就不需要 FileX，但同样需要暂停 MSC，因为主机仍然会发命令。

按以上步骤实现后，你就能在不中断 CDC 命令解析的前提下，安全地暂停 MSC、完成 FileX 读写测试、再恢复 USB 复合设备。需要我一起改源码或写互斥/控制函数的话，再告诉我。

```c
status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));
if (status != FX_SUCCESS)
{
    printf("挂载文件系统失败 -- %d\r\n", status);
    return;
}
```

```c
status =  HAL_SD_ReadBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);
...
status = HAL_SD_WriteBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);
```

```c
void fxSdTestSpeed(void)
{
    USBX_MSC_Pause();
    if (fx_media_open(... ) == FX_SUCCESS) {
        /* 做测速 */
        fx_media_close(&sdio_disk);
    }
    USBX_MSC_Resume();
}
```

---

**User**

USBX_MSC_Pause(); 和 USBX_MSC_Resume();我想在 @ux_device_msc.c 里定义，该如何写

---

**Cursor**

定义这两个函数时要做三件事：保存 MSC 注册所需的参数、提供互斥保护、防止重复调用。因为这些参数都是在 `app_usbx_device.c` 里配置的，所以要先把那里的 `storage_parameter`、`storage_interface_number`、`storage_configuration_number` 改成可被其它文件访问（去掉 `static` 或提供 `extern` 声明），这样 `ux_device_msc.c` 才能在暂停后重新注册 MSC。

参考实现思路：

```c
/* ux_device_msc.h */
UINT USBX_MSC_Pause(VOID);
UINT USBX_MSC_Resume(VOID);
```

```c
/* ux_device_msc.c */
#include "ux_api.h"
#include "ux_device_stack.h"
#include "ux_device_class_storage.h"
#include "ux_device_class_storage_entry.h"

/* 从 app_usbx_device.c 拿到注册参数 */
extern ULONG storage_configuration_number;
extern ULONG storage_interface_number;
extern UX_SLAVE_CLASS_STORAGE_PARAMETER storage_parameter;

/* 简单的状态与互斥 */
static TX_MUTEX msc_state_mutex;
static UINT     msc_is_online = UX_TRUE;

VOID USBX_MSC_InitControl(VOID)
{
    tx_mutex_create(&msc_state_mutex, "msc_state_mutex", TX_INHERIT);
}

UINT USBX_MSC_Pause(VOID)
{
    UINT status = UX_SUCCESS;

    tx_mutex_get(&msc_state_mutex, TX_WAIT_FOREVER);

    if (msc_is_online == UX_FALSE)
    {
        tx_mutex_put(&msc_state_mutex);
        return UX_SUCCESS;
    }

    /* 主动断开 USB 连接，避免主机继续访问 */
    ux_device_stack_disconnect();

    status = ux_device_stack_class_unregister(_ux_system_slave_class_storage_name,
                                              ux_device_class_storage_entry);
    if (status == UX_SUCCESS)
    {
        msc_is_online = UX_FALSE;
    }

    tx_mutex_put(&msc_state_mutex);
    return status;
}

UINT USBX_MSC_Resume(VOID)
{
    UINT status = UX_SUCCESS;

    tx_mutex_get(&msc_state_mutex, TX_WAIT_FOREVER);

    if (msc_is_online == UX_TRUE)
    {
        tx_mutex_put(&msc_state_mutex);
        return UX_SUCCESS;
    }

    status = ux_device_stack_class_register(_ux_system_slave_class_storage_name,
                                            ux_device_class_storage_entry,
                                            storage_configuration_number,
                                            storage_interface_number,
                                            &storage_parameter);
    if (status == UX_SUCCESS)
    {
        /* 重新“插入”设备让主机枚举 */
        ux_device_stack_connect();
        msc_is_online = UX_TRUE;
    }

    tx_mutex_put(&msc_state_mutex);
    return status;
}
```

使用方式：

1. 在 USBX 初始化完成后调用一次 `USBX_MSC_InitControl()` 创建互斥量。
2. 在 `$TEST_SD_SPEED` 命令里：
   - 调 `USBX_MSC_Pause();`
   - 执行 `fx_media_open()` → 测速 → `fx_media_close()`
   - 调 `USBX_MSC_Resume();`

这样就能在不改太多工程结构的情况下，让 MSC 先下线、完成 FileX 测试、再重新挂回主机。

```c
/* ux_device_msc.h */
UINT USBX_MSC_Pause(VOID);
UINT USBX_MSC_Resume(VOID);
```

```c
/* ux_device_msc.c */
#include "ux_api.h"
#include "ux_device_stack.h"
#include "ux_device_class_storage.h"
#include "ux_device_class_storage_entry.h"

/* 从 app_usbx_device.c 拿到注册参数 */
extern ULONG storage_configuration_number;
extern ULONG storage_interface_number;
extern UX_SLAVE_CLASS_STORAGE_PARAMETER storage_parameter;

/* 简单的状态与互斥 */
static TX_MUTEX msc_state_mutex;
static UINT     msc_is_online = UX_TRUE;

VOID USBX_MSC_InitControl(VOID)
{
    tx_mutex_create(&msc_state_mutex, "msc_state_mutex", TX_INHERIT);
}

UINT USBX_MSC_Pause(VOID)
{
    UINT status = UX_SUCCESS;

    tx_mutex_get(&msc_state_mutex, TX_WAIT_FOREVER);

    if (msc_is_online == UX_FALSE)
    {
        tx_mutex_put(&msc_state_mutex);
        return UX_SUCCESS;
    }

    /* 主动断开 USB 连接，避免主机继续访问 */
    ux_device_stack_disconnect();

    status = ux_device_stack_class_unregister(_ux_system_slave_class_storage_name,
                                              ux_device_class_storage_entry);
    if (status == UX_SUCCESS)
    {
        msc_is_online = UX_FALSE;
    }

    tx_mutex_put(&msc_state_mutex);
    return status;
}

UINT USBX_MSC_Resume(VOID)
{
    UINT status = UX_SUCCESS;

    tx_mutex_get(&msc_state_mutex, TX_WAIT_FOREVER);

    if (msc_is_online == UX_TRUE)
    {
        tx_mutex_put(&msc_state_mutex);
        return UX_SUCCESS;
    }

    status = ux_device_stack_class_register(_ux_system_slave_class_storage_name,
                                            ux_device_class_storage_entry,
                                            storage_configuration_number,
                                            storage_interface_number,
                                            &storage_parameter);
    if (status == UX_SUCCESS)
    {
        /* 重新“插入”设备让主机枚举 */
        ux_device_stack_connect();
        msc_is_online = UX_TRUE;
    }

    tx_mutex_put(&msc_state_mutex);
    return status;
}
```

---

**User**

我已经把挂载和恢复MSC的代码加入到源文件中，但USBD_STORAGE_Read/Write  tx_mutex_get(&sd_media_lock, TX_WAIT_FOREVER)，结束后释放该怎么添加？



---

**Cursor**

你已经把 MSC 暂停/恢复的接口加进 `ux_device_msc.c`，下一步是在 `USBD_STORAGE_Read` / `USBD_STORAGE_Write` 里围住底层 DMA 访问。建议做法：

1. **新增互斥量**  
   - `ux_device_msc.c` 顶部声明 `static TX_MUTEX sd_media_lock;` 并在某个初始化函数（例如你已有的 `USBX_MSC_InitControl()` 或 MSC 激活时）调用一次 `tx_mutex_create(&sd_media_lock, "sd_media_lock", TX_INHERIT);`  
   - 如果 `USBX_MSC_Pause/Resume` 也要用这个锁，就把它定义成全局 `extern TX_MUTEX sd_media_lock;`，或直接复用你现有的 `msc_state_mutex`。

2. **在读/写入口加锁/解锁**  
   ```c
   UINT USBD_STORAGE_Read(...)
   {
       UINT status = UX_SUCCESS;
   
       tx_mutex_get(&sd_media_lock, TX_WAIT_FOREVER);
   
       if (msc_is_online == UX_FALSE)   /* 如果 MSC 已被暂停，直接拒绝主机请求 */
       {
           tx_mutex_put(&sd_media_lock);
           return UX_ERROR;
       }
   
       /* 原来的 HAL_SD_ReadBlocks_DMA 流程... */
   
       tx_mutex_put(&sd_media_lock);
       return status;
   }
   ```

   写函数同理，注意所有可能的 `return` 路径都要 `tx_mutex_put()`；如果在 `_Error_Handler()` 之前就会卡死，可以在那之前也释放锁，避免下一次访问永远拿不到。

3. **FileX 测速函数也要拿同一把锁**  
   在 `fxSdTestSpeed()` 里，在 `USBX_MSC_Pause()` 之后加 `tx_mutex_get(&sd_media_lock, TX_WAIT_FOREVER);`，确保在重新 mount FileX 之前没人还能落入 MSC 读写；完成 `fx_media_close()` 后 `tx_mutex_put()` 再 `USBX_MSC_Resume()`。

这样读写路径就统一受 `sd_media_lock` 控制：MSC 正常在线时，主机访问可以拿锁；当你暂停 MSC 做 FileX 测试时，先暂停 MSC（断开 + unregister），拿锁做 FileX 操作，最后释放锁并重新注册 MSC。这样不会出现未同步的并发访问。

```c
   UINT USBD_STORAGE_Read(...)
   {
       UINT status = UX_SUCCESS;

       tx_mutex_get(&sd_media_lock, TX_WAIT_FOREVER);

       if (msc_is_online == UX_FALSE)   /* 如果 MSC 已被暂停，直接拒绝主机请求 */
       {
           tx_mutex_put(&sd_media_lock);
           return UX_ERROR;
       }

       /* 原来的 HAL_SD_ReadBlocks_DMA 流程... */

       tx_mutex_put(&sd_media_lock);
       return status;
   }
```

---

**User**

你说的 sd_media_lock 和 msc_state_mutex 是要使用同一个吗 @USBX/App/app_usbx_device.c:422-475 

---

**Cursor**

不一定必须共用，但建议分工明确：

- `msc_state_mutex`：目前你在 `USBX_MSC_Pause/Resume` 里用它来保护 “MSC 是否已注册” 这一状态，避免重复注销/注册。它只负责 MSC 类的生命周期管理。
- `sd_media_lock`：用于保护“真正的 SD 介质访问（HAL_SD_* + FileX 操作）”。主机通过 MSC、或本地 FileX 测速函数，任何一次读写都要先拿这把锁，确保同一时间只有一方占用 SD。

两把锁各自职能更清晰，也能避免因为“暂停/恢复”状态冲突导致的死锁或优先级倒置。典型流程：

1. `USBD_STORAGE_Read/Write`
   - `tx_mutex_get(&sd_media_lock)`
   - 检查 `msc_is_online`，若已暂停直接返回错误
   - 进行 DMA 访问
   - `tx_mutex_put(&sd_media_lock)`

2. `fxSdTestSpeed`
   - `USBX_MSC_Pause()`（内部用 `msc_state_mutex`）
   - `tx_mutex_get(&sd_media_lock)`，做 FileX `fx_media_open` 等操作
   - 完成后 `tx_mutex_put(&sd_media_lock)`
   - `USBX_MSC_Resume()`

如果你嫌两把锁太多，也可以用一把 `sd_media_lock` 同时保护“状态 + 访问”，但那样 `USBX_MSC_Pause()` 里就在操作状态时持有同一个互斥量，需保证所有使用者顺序一致，防止后续 FileX 访问时又调用 `USBX_MSC_Pause()` 造成死锁。为了简单稳定，保持两把锁就好。

---

**User**

我已经添加了你建议的所有修改，当电脑发送还$TEST_SD_SPEED时，是在  @app_demo_sd_filex.c (644) 

@app_demo_sd_filex.c (666-671) 

status是0x90



注意，我的USBX是复合设备有一个CDC ACM Class 和一个 MSC Class，所以USBX_MSC_Pause是不能执行ux_device_stack_disconnect()的，这会导致 CDC虚拟串口与电脑失去连接，无法打印 fxSdTestSpeed 的printf 结果

---

**Cursor**

### 关键点先说结论

- 你现在 `USBX_MSC_Pause()` 去掉 `ux_device_stack_disconnect()` 是对的，复合设备里不能把 CDC 一起拔掉。
- **`fx_media_open()` 返回 `0x90`，在你当前这种 64GB 卡场景，更大的概率不是“MSC 还在占用 SD”，而是：FileX 根本看不懂这张卡的文件系统（通常是 exFAT），所以直接返回 `FX_MEDIA_INVALID (0x90)`。  
  - 64GB SD 卡在 Windows 下默认格式就是 exFAT。  
  - Azure RTOS FileX 标准配置只支持 FAT12/16/32，不支持 PC 上这种 exFAT。

也就是说：  
**MSC 能正常工作，是因为 PC 自己在主机端解析 exFAT；  
FileX 失败，是因为它在设备端要自己解析 FAT，但读到的是 exFAT 的引导扇区，判断“不是我能认的介质”，返回 0x90。**

---

### 建议你这样验证一下

- 换一张 **8GB / 16GB** 的 SD 卡，在 PC 上**明确格式化为 FAT32**（注意不要选 exFAT）。  
- 再跑 `$TEST_SD_SPEED`，看 `fx_media_open()` 是否变为 `FX_SUCCESS`。  
- 如果目前 64GB 卡里数据不重要，也可以直接在设备端（或 PC）用 **FileX 的格式化流程**重新把它格式化成 FAT32，例如在“首次使用”时调用一次 `fx_media_format()`，以后就只在这个分区上用 FileX/PC 读写。

---

### 关于暂停 MSC + CDC 仍在线

- 你现在的 `USBX_MSC_Pause()` 里只做：

```c
status = ux_device_stack_class_unregister(_ux_system_slave_class_storage_name,
                                          ux_device_class_storage_entry);
```

这已经足够让 MSC 类停止使用 `USBD_STORAGE_Read/Write`，不会再去碰 SD；  
CDC ACM 线程、虚拟串口仍然在线，可以继续打印 `printf`，这正是我们要的效果。

---

### 小结

- 目前的 **互斥 + MSC 注销逻辑方向基本正确**，不会再有“FileX 和 MSC 争用 SD” 的问题。  
- `0x90` 是 FileX 不认这张盘的格式，而不是 MSC 还在占用；  
- 下一步重点是：**使用 FAT32 的 SD 卡（或用 FileX 自己格式化一次）来做测速**，这样 `fx_media_open()` 才有机会返回成功。

```c
status = ux_device_stack_class_unregister(_ux_system_slave_class_storage_name,
                                          ux_device_class_storage_entry);
```

---

**User**

谢谢！我已经修改为 FAT32文件系统了，下载后运行电脑可以正常识别到U盘（59.5G）此时点击播放视频文件，快进视频文件都正常，关闭视频后，我可以打开CDC虚拟串口，发送测速命令后，可以正常创建"Speed.txt，进行读写测试，并打印测试结果，测速期间和测速完毕后，电脑这边显示59.5G的U盘都是全程挂载状态，但是点击视频文件无法打开，之后鼠标图标一直转圈圈，此状态过了一段时间后，U盘和CDC串口都失去与电脑连接

---

**Cursor**

### 现象说明

- 现在 FileX 测速已经能跑完，并且在 U 盘里看到了 `Speed00.txt / Speed01.txt / Speed02.txt` 等文件，这是 **FileX 和 SD 驱动本身工作正常** 的信号。  
- 但**问题是**：测速时 U 盘在 Windows 里一直是“已挂载、可用”的状态，Windows 仍然认为自己独占这个 FAT32 文件系统；你在设备端又用 FileX 去改 FAT/FAT 表和目录。  
- 结果就是：  
  - Windows 之前缓存的目录/文件信息和盘上的真实内容不一致 → 打开视频时提示“目录名称无效”；  
  - 后续继续 I/O 时，SCSI 命令读到的结构越来越乱，Windows 判定这个 U 盘出错，最终把整个 USB 设备（包含 CDC）一起重置/断开，所以你看到 MSC 和 CDC 都掉线。

**这不是你的代码“锁没加好”，而是违反了“同一分区不能同时被两个文件系统独占管理”的根本限制。**

---

### 正确的使用方式建议

要保证可靠，只能满足一个要求：**测速时，Windows 不得再把这个分区当作已挂载的正常磁盘来使用**。实践上你可以选下面几种方案之一：

- **方案 A（简单、推荐）：要求 PC 先“弹出”再测速**
  1. 在 CDC 协议里约定：PC 端在发送 `$TEST_SD_SPEED` 之前，必须在资源管理器里对 `G:` 执行一次“弹出”/“安全删除硬件”。  
  2. 设备这边收到命令后再执行 `USBX_MSC_Pause()` + FileX 测速；期间不要再向主机提供正常的读写服务（你已经通过 `ux_device_stack_class_unregister` 做到了）。  
  3. 测完后可以 `USBX_MSC_Resume()`，这时 Windows 会重新枚举/挂载磁盘，目录结构是 FileX 修改后的新状态。  
  4. 如果检测到 MSC 还在工作（比如刚刚有读写错误），就拒绝测速命令，并在 CDC 回一条“请先在电脑上弹出 U 盘再测速”。

- **方案 B：由设备强制让 Windows 放弃这个磁盘**
  - 在 `USBX_MSC_Pause()` 里保持你现在的 `ux_device_stack_class_unregister`；  
  - 对于已在进行中的 SCSI 命令返回错误，让 Windows 认为这块盘已经“拔掉”或“严重错误”，它会自动卸载卷；  
  - 测速完成后，通过重新注册 MSC 并（必要时）触发一次总线重连，让 Windows 以“新插入 U 盘”的方式重新识别。  
  - 这相当于你看到的现象的“可控版本”：在测速时，磁盘在 Windows 那边就不应该再是一个正常可用的 `G:`。

- **无论哪种方案，有两个底线：**
  - **测速期间禁止在 Windows 端做任何对这个盘的操作**（包括资源管理器打开目录、播放器访问文件等）；  
  - 测试完成后，**必须让 Windows 重新枚举/重新挂载**，不能指望它在不重新扫描 FAT 的情况下继续使用刚才已经被 FileX 修改过的卷。

---

### 总结

你现在看到“测速成功、但随后点击视频打不开、再过一会儿 MSC+CDC 全掉线”，说明 **FileX 与 Windows 同时操作同一 FAT32 卷，已经导致文件系统被破坏或 I/O 超时**。  
下一步不是再加锁，而是从流程上保证：**测速那段时间，这个卷在 Windows 看来已经被安全移除或出错下线**；测完后再让它重新枚举。否则只要“边当 U 盘用边做测速”，都会复现类似问题。

---

**User**

windows端右键U盘点击弹出，U盘仍然在电脑端显示

---

**Cursor**

### 简单说结论

- 在 **USB 复合设备的 MSC 卷** 上，Windows 资源管理器右键“弹出”，**通常只是卸载文件系统，不一定把盘符和图标立刻从界面上消失**，这在复合设备/虚拟 U 盘上是很常见的行为。
- 关键不是“图标还在不在”，而是：**被“弹出”后，Windows 不再向这个 LUN 发送正常的读写 SCSI 命令**，此时你就可以在设备端用 FileX 做测速了。

### 怎么更稳一点

如果你希望在“弹出 + 测速”这一流程下更保险，可以在 MSC 里配合一个“介质已移除”的标志：

1. 加一个全局标志，例如在 `ux_device_msc.c` 里：

```c
volatile UINT g_sd_medium_present = UX_TRUE;
```

2. 在你准备测速、并要求 PC 先“弹出”之后，把它清零：

```c
// 收到 $TEST_SD_SPEED 前，PC 先弹出 G:
g_sd_medium_present = UX_FALSE;
```

3. 在 `USBD_STORAGE_Status` 里根据它返回“介质不存在”，让 Windows 彻底认为这张卡已经拔掉：

```c
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
    UX_PARAMETER_NOT_USED(storage_instance);
    UX_PARAMETER_NOT_USED(lun);
    UX_PARAMETER_NOT_USED(media_id);

    if (g_sd_medium_present == UX_FALSE)
    {
        *media_status = UX_DEVICE_CLASS_STORAGE_MEDIA_NOT_PRESENT;
        return UX_ERROR;
    }

    *media_status = UX_DEVICE_CLASS_STORAGE_MEDIA_OK;
    return UX_SUCCESS;
}
```

这样做之后：

- Windows 右键“弹出”后，它会认为介质已经被移除，不再对这个盘做正常 I/O；  
- 即使图标/盘符还挂在那儿，对你来说也是“安全窗口”，可以在设备端跑 `fxSdTestSpeed()` 而不再和主机抢占文件系统。

```c
volatile UINT g_sd_medium_present = UX_TRUE;
```

```c
// 收到 $TEST_SD_SPEED 前，PC 先弹出 G:
g_sd_medium_present = UX_FALSE;
```

```c
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
    UX_PARAMETER_NOT_USED(storage_instance);
    UX_PARAMETER_NOT_USED(lun);
    UX_PARAMETER_NOT_USED(media_id);

    if (g_sd_medium_present == UX_FALSE)
    {
        *media_status = UX_DEVICE_CLASS_STORAGE_MEDIA_NOT_PRESENT;
        return UX_ERROR;
    }

    *media_status = UX_DEVICE_CLASS_STORAGE_MEDIA_OK;
    return UX_SUCCESS;
}
```

---

**User**

好像库文件中没有 UX_DEVICE_CLASS_STORAGE_MEDIA_NOT_PRESENT 和 UX_DEVICE_CLASS_STORAGE_MEDIA_OK ，找下其他什么宏可以设置media_status？？@ux_device_class_storage.h 

---

**Cursor**

### 回答你的具体问题

- 在 `ux_device_class_storage.h` 里**确实没有**像 `UX_DEVICE_CLASS_STORAGE_MEDIA_NOT_PRESENT` / `MEDIA_OK` 这样的宏。  
- `media_status` 只是一个**给应用层自己用的状态值**，USBX 内核并不会强制要求它是什么具体宏，只要你和回调的 `return` 值（`UX_SUCCESS` or 错误码）配合一致即可。

### 实际可以这样写

你可以自己定义两个简单的状态，用在 `USBD_STORAGE_Status` 里：

```c
/* ux_device_msc.c 顶部（或公共头文件） */
#define MEDIA_STATUS_OK           0u
#define MEDIA_STATUS_NOT_PRESENT  1u
```

然后在 `USBD_STORAGE_Status` 中：

```c
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
    UX_PARAMETER_NOT_USED(storage_instance);
    UX_PARAMETER_NOT_USED(lun);
    UX_PARAMETER_NOT_USED(media_id);

    if (g_sd_medium_present == UX_FALSE)
    {
        *media_status = MEDIA_STATUS_NOT_PRESENT;
        return UX_ERROR;          // 告诉 USBX：介质有问题
    }

    *media_status = MEDIA_STATUS_OK;
    return UX_SUCCESS;            // 正常
}
```

要点是：

- **USBX 只关心返回值是 `UX_SUCCESS` 还是错误码**；  
- `*media_status` 你可以自定义，只要在自己代码里保持语义一致（0=OK，非0=异常）即可，库里没有固定宏。

```c
/* ux_device_msc.c 顶部（或公共头文件） */
#define MEDIA_STATUS_OK           0u
#define MEDIA_STATUS_NOT_PRESENT  1u
```

```c
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
    UX_PARAMETER_NOT_USED(storage_instance);
    UX_PARAMETER_NOT_USED(lun);
    UX_PARAMETER_NOT_USED(media_id);

    if (g_sd_medium_present == UX_FALSE)
    {
        *media_status = MEDIA_STATUS_NOT_PRESENT;
        return UX_ERROR;          // 告诉 USBX：介质有问题
    }

    *media_status = MEDIA_STATUS_OK;
    return UX_SUCCESS;            // 正常
}
```

---

**User**

添加了你说的 这个实现，在fxSdTestSpeed函数执行期间，电脑上U盘图标没有消失，fxSdTestSpeed执行完毕后，点击U盘里的文件，无法打开，鼠标一直转圈圈，之后windows移除了我的USBX设备，U盘和CDC串口都消失了

---

**Cursor**

### 先把结论说清楚

你现在遇到的现象（测速期间和之后，Windows 打不开文件、一直转圈，最后整个 USB 设备被移除）说明一件事：

> **在 MSC 还挂在 Windows 上的情况下，用 FileX 去改同一个 FAT32 卷，本质上是“破坏 Windows 正在使用的磁盘”，这是无法通过加锁/返回错误来彻底兜住的。**

即使：
- 你在设备端 `USBX_MSC_Pause()` 里 `class_unregister`；
- 在 `USBD_STORAGE_Status` 里报“介质不存在”；
Windows 还是会继续发一堆 SCSI 命令做恢复、重试、同步 cache，一旦响应不符合预期，就会把整个 USB 设备 reset 掉，于是 **MSC + CDC 一起消失**——这正是你看到的行为。

### 这意味着什么？

在 **单个 USB 复合设备（CDC+MSC）+ 单分区 SD 卡** 的架构下：

- 想要：
  - Windows 端 U 盘一直保持“在线可用”，  
  - 同时设备端用 FileX 在同一个分区上随意创建/删除/重写大文件做测速，  
- 这是从设计上 **做不到“既安全又稳定”** 的。  
  无论我们怎么在驱动里“骗” Windows（报介质不存在、返回错误等），Windows 一旦发现卷结构被外部改乱，就会认为设备异常并断开。

### 你现在可行的几种安全方案（要选一个取舍）

- **方案 1：测速时真的断开 MSC，允许 CDC 短暂中断**
  - 启动测速命令时：
    - 调 `ux_device_stack_disconnect()` 或直接关闭 USB PCD；
    - `ux_device_stack_class_unregister` MSC；
  - 测速用 FileX 完成后，再重新 `class_register` + 重新连接总线（Windows 会重新枚举 U 盘）。
  - 缺点：测速这段时间 CDC 也会掉线；优点：**文件系统绝对安全**，不会把卡搞坏。

- **方案 2：测速只在“未连接 PC 时”跑**
  - 例如只在上电自检、或者检测不到 VBUS 的时候，用 FileX 对整盘做读写测速；
  - 一旦 USB 连上 PC 并枚举 MSC 以后，就不再允许 `$TEST_SD_SPEED`，CDC 上直接返回“当前已连接 PC，不支持测速”。
  - 这是很多产品的做法：**测速是出厂/调试功能，不在“当作 U 盘使用时”启用。**

- **方案 3：改架构，不用“MSC + FileX 共享同一卷”测速**
  - 例如：
    - 放弃 MSC，只保留 CDC，通过自定义协议从 PC 传/收文件（设备内部统一用 FileX）；  
    - 或者把 SD 卡分多个分区，一部分只给 MSC，另一部分只给 FileX（实现复杂，而且 STM32 + Azure RTOS 官方例程并不直接支持多分区管理，要自己维护 LBA 映射）。  
  - 这就是从根上避免“两个文件系统操作同一个卷”。

- **方案 4：测速只做“裸扇区吞吐量测试”，不再用 FileX**
  - 在 `$TEST_SD_SPEED` 里：
    - 不 `fx_media_open`，不改 FAT/目录；
    - 直接调用 `HAL_SD_ReadBlocks_DMA / WriteBlocks_DMA` 在某个 **不被 Windows 使用的 LBA 区间** 做读写测试，只测裸带宽；
  - 但前提还是：测试期间 Windows 不能在这些 LBA 上做 I/O，否则一样会出错。要么事先预留一段逻辑地址完全不映射到卷，要么同样在“未挂载”场景下测。

### 回答你现在做法的状态

- 你已经验证：  
  - FAT32 + FileX 测速本身是通的；  
  - 问题只在于“测速前后，Windows 仍认为这是同一个、一直在线的 U 盘”。
- 在这种前提下，**继续尝试“让 U 盘图标不消失、CDC 不掉线，同时还跑 FileX 改同一分区”是不现实的目标**。

### 建议你现在怎么收尾

如果你最看重的是“**产品稳定、U 盘不容易挂掉**”，我建议：

1. 把 `$TEST_SD_SPEED` 明确定位为“**脱机/调试模式功能**”：只有在未连接 PC（或 USB 未枚举 MSC）时才允许执行；
2. 正式给用户用的固件里，**禁止在 MSC 已挂载时跑 FileX 测速**，CDC 上直接回一条错误说明原因。

如果你更希望继续探索“断 MSC 保 CDC”的细方案，我们也可以继续一起看怎么改枚举/配置描述符，但那会牵扯到整体 USB 设计，不只是几行代码能解决的事。

---

**User**

我对另外一个非复合设备工程仅MSC类，在win11下可以点击“弹出STM32 V1.0”，以达到弹出U盘的目的，但为什么对本工程的 MSC + CDC 复合设备在win11下不能点击 “弹出STM32 V1.0”（是灰色的），但可以点击弹出U盘（G：）但点击后没有反应，U盘还是在电脑上显示，是设备描述符需要去掉MSC的部分更新描述符才能吗？





---

**Cursor**

这里不是描述符问题，主要是 MSC 侧没有把“介质可拔/可移除”和“已移除”这套流程做好，导致 Win11 无法完成弹出：  
- Win11 的“弹出 STM32 V1.0”会灰掉是因为它把你的复合设备看成“还有其它功能（CDC）在用”，只能弹出卷（G:）。  
- 点击弹出 G: 后卷不消失，说明主机发的 SCSI 命令（如 START STOP UNIT、PREVENT/ALLOW MEDIUM REMOVAL、SYNCHRONIZE CACHE 等）没有得到合适响应，或设备一直报告“介质在位/可访问”，所以 Windows 不敢卸载卷。

改动建议（无需改描述符）：  
1) 确保 LUN 标为可移除  
```c
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_removable_flag = UX_TRUE;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_read_only_flag = UX_FALSE;
```

2) 正确处理介质锁定/弹出  
- 在 `_ux_device_class_storage_prevent_allow_media_removal()` 里接受主机的解除/锁定请求（不要一直返回失败）。  
- 在 `_ux_device_class_storage_start_stop()` 或你自己的回调里处理 STOP 位：当主机请求停止/卸出时，设置 `media_present = UX_FALSE`。  
- 在 `USBD_STORAGE_Status()` 检查 `media_present`，如果为假，`*media_status` 给出非 0 值并返回 `UX_ERROR`，让主机认为介质已被移除。  
- 在 `USBD_STORAGE_Read/Write` 如果 `media_present == false`，直接返回 `UX_ERROR`，并设置合适的 SENSE（NOT_READY/UNIT_ATTENTION）。这样 Windows 会卸载卷，图标消失或变灰。

3) 同步缓存  
- 如果主机发 `SYNCHRONIZE CACHE`，要返回成功，避免被判为设备错误。

4) 不要指望“弹出后 CDC 还在、MSC 继续在线但卷已卸载”完全无缝：  
- 做到上面的“介质已移除”逻辑后，MSC 接口仍在，但主机会把卷卸掉；CDC 仍可用。  
- 如果你还想在设备侧继续 FileX 测试，最好在主机弹出后标记 `media_present = false`，此时主机不会再读写卷，你可以安全地用 FileX；测完后若要重新让主机使用，重新置 `media_present = true`，并（必要时）触发一次 MSC 重新注册或总线断/连，让主机重新枚举卷。

5) 如果仍然无法弹出：  
- 在弹出命令到来后，直接把 MSC 的 “介质在位” 标志改为假，并对后续 Test Unit Ready 返回 NOT_READY，这通常能让 Windows 卸载卷。  
- 作为最后手段，可以在 MSC 侧收到 STOP UNIT 时主动 `ux_device_stack_disconnect()` 再 `connect()`，让主机重新枚举（但这会导致 CDC 也掉线，通常不建议在复合设备里这样做）。

总结：不用改描述符，关键是实现“介质可移除”的 SCSI 流程，让 Windows 看到“介质已移除”，卷才会真正卸载。

```c
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_removable_flag = UX_TRUE;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_read_only_flag = UX_FALSE;
```

---

**User**

  你建议我添加的



storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_removable_flag = UX_TRUE;



storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_read_only_flag = UX_FALSE;



在CubeMX生成的代码中已经有 

#ifndef STORAGE_REMOVABLE_FLAG

#define STORAGE_REMOVABLE_FLAG   0x80U

#endif

#ifndef STORAGE_READ_ONLY

#define STORAGE_READ_ONLY    UX_FALSE

  storage_parameter.ux_slave_class_storage_parameter_lun[0].

    ux_slave_class_storage_media_removable_flag = STORAGE_REMOVABLE_FLAG;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].

    ux_slave_class_storage_media_read_only_flag = STORAGE_READ_ONLY;

orage_media_removable_flag = UX_TRUE;

---

**Cursor**

了解，你的 CubeMX 模板里已经把：

- `ux_slave_class_storage_media_removable_flag = STORAGE_REMOVABLE_FLAG`（值 0x80）
- `ux_slave_class_storage_media_read_only_flag = UX_FALSE`

都设置了，所以“可移除/可写”标志已经到位。现在弹出/卸载的问题不在这里，而在于 SCSI 命令处理和介质状态的配合。重点放在：

1) 处理 START STOP UNIT / PREVENT ALLOW MEDIA REMOVAL  
- 在 `_ux_device_class_storage_prevent_allow_media_removal()` 里不要一律拒绝；当主机请求允许移除时（Prevent=0），标记“可弹出”。  
- 在 `_ux_device_class_storage_start_stop()` 里，当主机请求 STOP/LOEj（卸载介质）时，设置 `media_present = UX_FALSE`。

2) 在 `USBD_STORAGE_Status` 里报告介质状态  
- 如果 `media_present == UX_FALSE`，给 `*media_status` 一个非零值并返回 `UX_ERROR`（例如自定义 1 表示 not present）。  
- `USBD_STORAGE_Read/Write` 也要检查这个标志，若介质已移除则直接返回 `UX_ERROR`，并设置合适的 SENSE（NOT_READY/UNIT_ATTENTION）。

3) 确认 SYNCHRONIZE CACHE 返回成功  
- 不要让主机在同步缓存时收到错误，否则它会判定设备异常。

这样做的目的：当用户在 Win11 里“弹出 U 盘”时，主机发的 SCSI 停止/允许移除命令能得到正确响应，随后 Test Unit Ready 返回“介质不在”，Windows 才会真正卸载卷，图标变灰或消失，不再继续访问，从而避免你后续用 FileX 修改卷时被主机干扰。

---

**User**

USBX库里 @ux_device_class_storage_prevent_allow_media_removal.c (78) 执行了一个 空宏函数 UX_TRACE_IN_LINE_INSERT （是TraceX的监控函数），什么都没有做就返回 UX_SUCCESS， @ux_device_class_storage_start_stop.c (77) 也执行了一个 空宏函数 UX_TRACE_IN_LINE_INSERT （是TraceX的监控函数），什么都没有做就返回 UX_SUCCESS， 
那我如何检测到SCSI命令在 
@ux_device_msc.c (267-283) 里响应，我上一次仅MSC设备的工程此USBD_STORAGE_Status 函数也是保持不写但可以弹出U盘

---

**Cursor**

可以这样做：在应用侧自己接管“介质是否在位”的标志，并在 SCSI START/STOP 里把它置成“不在位”，然后在 `USBD_STORAGE_Status` / Read / Write 里依据这个标志返回错误。这样 Windows 收到 STOP+LOEJ 后就会卸载卷，你也能在 app 里“看见”这条弹出请求。

### 1. 在 `ux_device_msc.c` 加介质状态标志
```c
/* 全局标志 */
volatile UINT g_media_present = UX_TRUE;

/* 用于被 start/stop 调用 */
VOID ux_app_msc_media_eject(VOID)
{
    g_media_present = UX_FALSE;
}
```

### 2. `USBD_STORAGE_Status` 按标志返回
```c
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
    UX_PARAMETER_NOT_USED(storage_instance);
    UX_PARAMETER_NOT_USED(lun);
    UX_PARAMETER_NOT_USED(media_id);

    if (g_media_present == UX_FALSE) {
        *media_status = 1;      // 自定义非 0 即可
        return UX_ERROR;        // 让主机认为介质不在
    }
    *media_status = 0;
    return UX_SUCCESS;
}
```
`USBD_STORAGE_Read/Write` 同样在开头检查 `g_media_present`，为假时直接 `return UX_ERROR;`，以防主机继续访问。

### 3. 在 `ux_device_class_storage_start_stop.c` 捕获弹出
编辑该文件，解析 CDB 的第 5 字节（cbwcb[4]）：

```c
UCHAR loej  = cbwcb[4] & 0x02; // Load/Eject 位
UCHAR start = cbwcb[4] & 0x01; // Start 位

if (loej && !start) {
    /* 主机请求卸载介质 */
    extern VOID ux_app_msc_media_eject(VOID);
    ux_app_msc_media_eject();
}
```

保持函数仍然 `return UX_SUCCESS;`，只是增加了这条钩子。

### 4. 可选：在 `prevent_allow_media_removal` 里记录允许弹出
同理，在 `ux_device_class_storage_prevent_allow_media_removal.c` 里解析参数，如果主机设置 “允许移除”，也可以清除一个“锁定”标志；但关键还是 START/STOP 的 LOEJ+STOP。

### 5. 为什么单 MSC 工程不用改
有些主机在“安全移除”时仅靠 START/STOP，就能拿到 NOT_PRESENT，卷就消失了；你之前的工程或许无其他类干扰、且偶然行为不同。但在复合设备下，确保 START/STOP 时明确告知“介质已移除”是最可靠的方式。

这样改完后，当 Win11 发送弹出命令时：
- `start_stop` 钩子把 `g_media_present` 清零；
- 后续 Test Unit Ready / Status / Read/Write 都报介质不在；
- Windows 卸载卷，图标消失或变灰，避免再去访问，也不会因访问失败把整个设备（包含 CDC）重置。

```c
/* 全局标志 */
volatile UINT g_media_present = UX_TRUE;

/* 用于被 start/stop 调用 */
VOID ux_app_msc_media_eject(VOID)
{
    g_media_present = UX_FALSE;
}
```

```c
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
    UX_PARAMETER_NOT_USED(storage_instance);
    UX_PARAMETER_NOT_USED(lun);
    UX_PARAMETER_NOT_USED(media_id);

    if (g_media_present == UX_FALSE) {
        *media_status = 1;      // 自定义非 0 即可
        return UX_ERROR;        // 让主机认为介质不在
    }
    *media_status = 0;
    return UX_SUCCESS;
}
```

```c
UCHAR loej  = cbwcb[4] & 0x02; // Load/Eject 位
UCHAR start = cbwcb[4] & 0x01; // Start 位

if (loej && !start) {
    /* 主机请求卸载介质 */
    extern VOID ux_app_msc_media_eject(VOID);
    ux_app_msc_media_eject();
}
```

---

**User**



VOID ux_app_msc_media_eject(VOID) /* 用于被 start/stop 调用 */，是被什么函数调用？

---

**Cursor**

它需要你在 `ux_device_class_storage_start_stop.c` 里主动调用。做法：

- 在 `ux_device_msc.c` 里实现：  
  ```c
  volatile UINT g_media_present = UX_TRUE;
  VOID ux_app_msc_media_eject(VOID)
  {
      g_media_present = UX_FALSE;
  }
  ```
- 然后修改 `Middlewares/ST/usbx/common/usbx_device_classes/src/ux_device_class_storage_start_stop.c`，在解析 CDB 时检测主机发来的 STOP/LOEJ 请求并调用它。例如：

  ```c
  /* cbwcb[4] 的 bit1=LOEJ，bit0=START */
  UCHAR loej  = cbwcb[4] & 0x02;
  UCHAR start = cbwcb[4] & 0x01;
  
  if (loej && (start == 0))
  {
      extern VOID ux_app_msc_media_eject(VOID);
      ux_app_msc_media_eject();   // 标记介质已移除
  }
  ```

这样 `ux_app_msc_media_eject()` 就是在 SCSI START/STOP 命令处理函数里被调用，用来把 `g_media_present` 清零，让后续 `USBD_STORAGE_Status` / Read / Write 返回“介质不在”。

```c
  volatile UINT g_media_present = UX_TRUE;
  VOID ux_app_msc_media_eject(VOID)
  {
      g_media_present = UX_FALSE;
  }
```

```c
  /* cbwcb[4] 的 bit1=LOEJ，bit0=START */
  UCHAR loej  = cbwcb[4] & 0x02;
  UCHAR start = cbwcb[4] & 0x01;

  if (loej && (start == 0))
  {
      extern VOID ux_app_msc_media_eject(VOID);
      ux_app_msc_media_eject();   // 标记介质已移除
  }
```

---

**User**

我已经添加了修改 @ux_device_class_storage_start_stop.c (77) 、 @ux_device_msc.c (272) ，现在电脑U盘点击弹出后，资源管理器会卡顿几秒钟，然后U盘容量信息消失，变为图1，若点击U盘，则又会卡顿几秒钟弹出不可访问的串口如图2，如何减少这个卡顿？
当 MSC 设备的U盘点击显示不可访问后，我的复合设备中的CDC ACM串口还可以和电脑正常收发命令，如图3
我在电脑点击出U盘使，进行了断点调试，发现会执行 @Middlewares/ST/usbx/common/usbx_device_classes/src/ux_device_class_storage_read_capacity.c:114-134 中的 _ux_device_stack_endpoint_stall(endpoint_in);


---

**Cursor**

出现卡顿是因为主机在弹出后仍然发了一轮 SCSI（含 READ CAPACITY、TEST UNIT READY 等），你的 `media_status` 报错后，USBX 按规范去 STALL IN 端点（`_ux_device_stack_endpoint_stall(endpoint_in)`），主机要等超时/重置端点，资源管理器才松手，这几秒就是这个等待过程。

想减少卡顿，可以选下面的策略，按侵入性从小到大排列：

1) 让 READ CAPACITY 等命令直接成功但回报“空盘”  
   - 在弹出后，`media_present == false` 时不要返回 `UX_ERROR`，改成 `return UX_SUCCESS`，但把 `media_status` 填成自定义非 0（例如 1），并把 LBA/BlockLen 返回为 0（或保持上次值，但关键是 success）。  
   - 这样 USBX 不会走到 STALL，Windows会收到“容量为 0/已移除”，通常会更快结束对话。  
   - 注意：要保证 Read/Write 在这段时间仍然拒绝（return UX_ERROR），以防主机又尝试 I/O。

2) 在弹出时主动断开端点，强制重连  
   - 在收到 START/STOP 的弹出请求后直接 `ux_device_stack_disconnect()`，等 500ms 后 `ux_device_stack_connect()`；主机会把卷卸载，这样没有 STALL 等待，但 CDC 也会断线（不满足你要 CDC 持续在线）。

3) 缩短主机等待：避免重复 STALL  
   - 当前逻辑：`USBD_STORAGE_Status` 返回错误 → `_ux_device_class_storage_read_capacity` STALL → 主机清 stall，再来一轮 → 再 STALL。  
   - 可以在第一次 STALL 后设置一个标志，在后续命令里直接返回成功（容量 0），不再 STALL，减少往返。

4) 若允许，直接对所有 “容量/就绪” 命令返回成功且“介质不在”，不 STALL  
   - `USBD_STORAGE_Status`: media_present=false 时 `*media_status = 1; return UX_SUCCESS;`  
   - `USBD_STORAGE_Read/Write`: 仍然 return UX_ERROR（防止访问）。  
   - 这样大部分路径不会触发 STALL，卡顿会比现在短。

推荐先尝试方案 1：在弹出后的 READ CAPACITY/READ FORMAT CAPACITY 路径里返回成功而不是错误，避免 STALL。CDC 保持在线，资源管理器卡顿时间通常会缩短到 1~2 秒或更少。

---

**User**

如果USBD_STORAGE_Status返回UX_SUCCESS，那么弹出U盘media_status 在@ux_device_class_storage_read_capacity.c (95) 中是赋值给@Middlewares/ST/usbx/common/usbx_device_classes/src/ux_device_class_storage_read_capacity.c:120 
storage -> ux_slave_class_storage_lun[lun]结构体元素的，ux_slave_class_storage_request_sense_status成员的，

我在USBX的其他地方也见到了 storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = 这样的赋值语句，例如
@Middlewares/ST/usbx/common/usbx_device_classes/src/ux_device_class_storage_format.c:101-104 中我看到了一个 UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01)
此宏意思是：
@Middlewares/ST/usbx/common/usbx_device_classes/inc/ux_device_class_storage.h:518 

那你说的 “在弹出后，media_present == false 时不要返回 UX_ERROR，改成 return UX_SUCCESS，但把 media_status 填成自定义非 0（例如 1）”，media_status 给一个简单的1是不是不妥？

---

**Cursor**

用 1 这种随便的值确实太“随意”，建议用标准 SENSE 组合，让主机能正确理解“介质已移除”，但又不触发大规模 STALL。

可用的组合（常见约定）：
- “介质不存在” / “未就绪”：
  - `key = 0x02 (NOT READY)`
  - `asc = 0x3A (MEDIUM NOT PRESENT)`
  - `ascq = 0x00`
  - 宏值：`UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00)`
- （可选）“介质变更”：
  - `key = 0x06 (UNIT ATTENTION)`
  - `asc = 0x28 (NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED)`
  - `ascq = 0x00`

建议的返回方式：
```c
/* 弹出后 media_present == false 时 */
*media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
/* 这里返回 UX_SUCCESS，避免 STALL，让主机用 sense 状态判断介质不在 */
return UX_SUCCESS;
```

对 Read/Write：
- 仍然直接 `return UX_ERROR`（或也返回 SUCCESS，但 media_status 带上述 sense），目的是阻止真正的数据 I/O。

效果：
- `ux_device_class_storage_read_capacity` 会把你填的 `media_status` 写入 `ux_slave_class_storage_request_sense_status`，主机读到标准的 NOT READY / MEDIUM NOT PRESENT，就会更快放弃访问，卡顿时间通常比随便给 1 并 STALL 要短。

```c
/* 弹出后 media_present == false 时 */
*media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
/* 这里返回 UX_SUCCESS，避免 STALL，让主机用 sense 状态判断介质不在 */
return UX_SUCCESS;
```

---

**User**

我已经加入了 *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);

主机点击弹出U盘确实不会卡顿了，但之后U盘还是处于可访问状态，点击U盘还是可以播放其中的视频文件，是不是media_status 设置得不对？

---

**Cursor**

`media_status` 只在读容量等路径被记录，但主机要真正“认为盘没了”，还需要配合两件事：

1) **Read/Write 必须拒绝**  
   在 `USBD_STORAGE_Read/Write` 里，`media_present == UX_FALSE` 时直接返回 `UX_ERROR`，不要再走 DMA。否则主机还能正常读到数据，它就当盘还在。

2) **容量要变成 0**  
   即便你返回了 sense，当前代码仍然把原来的容量返回给主机，资源管理器还会试着访问。让容量为 0，点击盘就会立刻失败、不会继续播放。
   - 在 `USBD_STORAGE_GetMediaLastLba()`/`GetMediaBlocklength()` 里加判断：
   ```c
   if (g_media_present == UX_FALSE) {
       return 0;   // LastLba
   }
   ```
   或者 LastLba=0、BlockLen 保留原值也行，核心是总容量为 0。
   - 或在 Read Capacity 处理里（不改库的话），在 ejected 状态下填入 0 容量的返回值。

同时，为了减少卡顿，`USBD_STORAGE_Status` 可以继续：
```c
*media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
return UX_SUCCESS; // 不触发 STALL
```

这样组合的效果：
- Test Ready/Read Capacity 时，sense 表示“介质不在”，容量为 0；
- Read/Write 直接失败；
主机会很快把卷标为不可用，无法再打开/播放。

```c
   if (g_media_present == UX_FALSE) {
       return 0;   // LastLba
   }
```

```c
*media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
return UX_SUCCESS; // 不触发 STALL
```

---

**User**

我已经加入了 USBD_STORAGE_GetMediaBlocklength 和 USBD_STORAGE_GetMediaLastLba 检测 g_media_present 后修改返回值为 0U，但是我实际测试发现点击弹出U盘后，这两个函数并不会被调用

---

**Cursor**

`GetMediaLastLba/Blocklength` 只在主机做 READ CAPACITY 时才会调，一般只在枚举/复位后用一次。点击“弹出”后，Windows 多半只发 Test Unit Ready / Start-Stop / Prevent-Allow，不再发 READ CAPACITY，所以你现在加的 0 返回值不会被用到。

要让弹出后立刻不可访问，关键在这几个点：

1) 确保有地方把 `g_media_present` 置成 `UX_FALSE`
   - 在 `ux_device_class_storage_start_stop.c` 捕获 LOEJ+STOP 并调用：
     ```c
     if (loej && (start == 0)) { extern VOID ux_app_msc_media_eject(VOID); ux_app_msc_media_eject(); }
     ```
   - 或者在收到 CDC 命令/你自己的“暂停 MSC”流程里直接调用 `ux_app_msc_media_eject()`，不要依赖主机一定发 START/STOP。

2) `USBD_STORAGE_Read/Write` 必须拒绝
   ```c
   if (g_media_present == UX_FALSE) {
       /* 可选：设置 sense 为 NOT READY / MEDIUM NOT PRESENT */
       return UX_ERROR;
   }
   ```
   这样主机一旦再读写就直接失败，视频等内容不会再被读出来。

3) `USBD_STORAGE_Status` 返回“介质不在”
   ```c
   if (g_media_present == UX_FALSE) {
       *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00); // NOT READY / MEDIUM NOT PRESENT
       return UX_SUCCESS; // 避免 STALL 卡顿
   }
   *media_status = 0;
   return UX_SUCCESS;
   ```

4) 可选：如果想更快让卷下线，可在 Test Unit Ready 路径返回 UX_ERROR（会触发 STALL+清除，可能稍有卡顿），或者只返回 SUCCESS+sense 如上，主机会把卷标为不可用。

总结：不用指望 eject 后再调用 `GetMedia*`。让 `g_media_present` 变 false，并在 Read/Write/Status 里基于这个标志返回失败/NOT READY sense，主机才能立刻认为介质已移除，点击盘就会失败，不再播放文件。

```c
     if (loej && (start == 0)) { extern VOID ux_app_msc_media_eject(VOID); ux_app_msc_media_eject(); }
```

```c
   if (g_media_present == UX_FALSE) {
       /* 可选：设置 sense 为 NOT READY / MEDIUM NOT PRESENT */
       return UX_ERROR;
   }
```

```c
   if (g_media_present == UX_FALSE) {
       *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00); // NOT READY / MEDIUM NOT PRESENT
       return UX_SUCCESS; // 避免 STALL 卡顿
   }
   *media_status = 0;
   return UX_SUCCESS;
```

---

**User**

在 USBD_STORAGE_READ/Write 函数中返回 UX_ERROR后，例如 ux_slave_class_storage_media_write 函数指针会去调用  USBD_STORAGE_Write，若是 返回 UX_ERROR 也会执行  _ux_device_stack_endpoint_stall(endpoint_out);



    @Middlewares/ST/usbx/common/usbx_device_classes/src/ux_device_class_storage_write.c:257-276 

---

**Cursor**

是的，当前库实现里，如果 `USBD_STORAGE_Write/Read` 返回 `UX_ERROR`，上层 `_ux_device_class_storage_write/read` 会立即 `STALL` 端点（你看到的 257-276），这会导致 Windows 等待清除 STALL，卡顿几秒。

要减少卡顿，可以在“介质已移除”状态下改成“成功但带错误感知”的返回模式：

做法（读写同理，写为例）：
```c
UINT USBD_STORAGE_Write(...) {
    if (g_media_present == UX_FALSE) {
        // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
        if (media_status) {
            *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
        }
        return UX_SUCCESS;  // 返回成功，避免上层 STALL
    }
    // 正常路径...
}
```

对应地，在 `USBD_STORAGE_Read` 也这样处理。

配合之前 `USBD_STORAGE_Status` 的处理：
```c
if (g_media_present == UX_FALSE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
    return UX_SUCCESS;  // 不触发 STALL
}
```

效果：
- 主机继续发送读写时，你返回 SUCCESS，但带有 “介质不在” 的 sense 码，上层不 STALL，卡顿时间显著缩短。
- 主机会把卷标为不可用，无法再播放文件；CDC 仍然在线。

如果仍希望完全拒绝读写且接受少量 STALL，可保留 `UX_ERROR`，但会有刚才的卡顿；上述方式是减少 STALL 的折衷方案。

```c
UINT USBD_STORAGE_Write(...) {
    if (g_media_present == UX_FALSE) {
        // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
        if (media_status) {
            *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
        }
        return UX_SUCCESS;  // 返回成功，避免上层 STALL
    }
    // 正常路径...
}
```

```c
if (g_media_present == UX_FALSE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
    return UX_SUCCESS;  // 不触发 STALL
}
```

---

**User**

太感谢 GPT 老师辣，我已经加入了你的修改，现在电脑点击弹出 U 盘终于能迅速弹出且变为FAT32状态！之后复合设备的CDC串口还是可以正常收发命令，真的是折腾了好久呢！

---

**Cursor**

太好了，终于把弹出和 CDC 并存的问题解决了！祝你后面调试顺利。如果后面还想优化，比如：

- 弹出后自动触发一次 FileX 测速，再自动恢复 MSC 枚举；
- 或者对 “未弹出就发测速命令” 做更明确的 CDC 提示；

都可以再聊。祝项目顺利！

---

**User**

你好，我现在用电脑将U盘弹出后，通过CDC发送命令$TEST_SD_SPEED，然后 @APP/app_demo_sd_filex.c:651-843 fxSdTestSpeed被执行，这个函数测速会在U盘（即SD卡）里创建一个"Speed%02d.txt"文件进行读写测试，测试完毕后，此文件还在U盘内，之后 @APP/app_demo_sd_filex.c:842 将 g_media_present = UX_TRUE ，则电脑会不认U盘，U盘变为一个G/?的卷标，这是不是windows检测到FAT表和cache里不一致导致的，这怎么解决？

---

**Cursor**

`G:?` 说明主机拿到的盘信息/缓存和当前 FAT 表不一致。测完后你只是把 `g_media_present` 设回 `UX_TRUE`，但没有告诉主机“介质发生了变化”，也没有强制重新枚举，所以 Windows 还在用旧的卷缓存来解析已被你改过的 FAT/目录，结果显示成未知卷。

避免这种现象可以用下面两种方式二选一：

**方式 A：重枚举 MSC（最稳）**
- 测速结束后：
  1) `fx_file_close` + `fx_media_flush` + `fx_media_close`（你已有）。
  2) `ux_device_stack_class_unregister(_ux_system_slave_class_storage_name, ...)`
  3) 重新 `ux_device_stack_class_register(...)`，必要时 `ux_device_stack_disconnect()` → `connect()`。
- 这样主机会当作一个新插入的 U 盘重新枚举，目录/FAT 全部重新读取，不会使用旧缓存。

**方式 B：用 SENSE 通知“介质已更换”**
- 增加一个 `media_changed` 标志，测速结束后设为 `true`。
- 在 `USBD_STORAGE_Status` / `Read` / `Write` 首次被调用时，如果 `media_changed` 为真，返回：
  - `*media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);` // UNIT ATTENTION, NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED
  - `return UX_SUCCESS;`
  - 并清掉 `media_changed`。
- 这样 Windows 会收到“介质已改变”，重新读 FAT/目录，盘符正常恢复。

无论哪种方式，确保测速结束后已经 `fx_media_flush` 和 `fx_media_close`，再让主机看到介质。这样就不会出现 `G:?`。

---

**User**

方案A测试了，没有用，还是显示 G\? @USBX/App/app_usbx_device.c:415-437 @APP/app_demo_sd_filex.c:844 @APP/app_demo_sd_filex.c:663 

---

**Cursor**

`G:?` 说明主机在重新挂盘时仍用的是旧缓存，认为卷结构不对。单纯在设备内部 `class_unregister / class_register` 主机是感觉不到的，它没有重新枚举 MSC，也没收到“介质已更换”的提示。

要让主机正常重新识别，有两种可选方案：

### 方案 1：让主机看到真正的“介质变更” (不强制断总线，CDC 可保持)
1. 测速前：`g_media_present = UX_FALSE`，走你的 Pause 流程。
2. 测速结束：`fx_media_flush` + `fx_media_close`。
3. 设置：
   ```c
   g_media_present  = UX_TRUE;
   g_media_changed  = UX_TRUE;   // 新增标志
   ```
4. 在 `USBD_STORAGE_Status/Read/Write` 中：
   - 如果 `g_media_present == UX_FALSE`：返回 NOT PRESENT（你已有）。
   - 如果 `g_media_changed == UX_TRUE`：
     ```c
     *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00); // UNIT ATTENTION, MEDIUM MAY HAVE CHANGED
     g_media_changed = UX_FALSE;   // 只报一次
     return UX_SUCCESS;            // 不要 UX_ERROR，避免 STALL
     ```
     这样主机会收到“介质已更换”，会重读 FAT/目录，不用断开 CDC，也不会出现 G:?。

### 方案 2：强制主机重新枚举 MSC（最稳，但 CDC 会掉线）
在测速结束后：
```c
fx_media_close(...);
g_media_present = UX_TRUE;
ux_device_stack_disconnect();      // 让主机看到拔出
USBX_MSC_Resume();                 // 重新注册 MSC
HAL_PCD_Start(...) 或 ux_device_stack_connect();  // 重新上线，主机会当新插入的盘
```
主机会完整地重新枚举卷，不会再用旧缓存。但 CDC 会随之断开再连。

如果你要保持 CDC 不掉线，优先用方案 1，并确保：
- Read/Write 在介质移除时不 STALL（返回 SUCCESS + sense）；  
- 在第一次 Status/Read/Write 后清掉 `g_media_changed`，让后续访问恢复正常容量和读写。

```c
   g_media_present  = UX_TRUE;
   g_media_changed  = UX_TRUE;   // 新增标志
```

```c
     *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00); // UNIT ATTENTION, MEDIUM MAY HAVE CHANGED
     g_media_changed = UX_FALSE;   // 只报一次
     return UX_SUCCESS;            // 不要 UX_ERROR，避免 STALL
```

```c
fx_media_close(...);
g_media_present = UX_TRUE;
ux_device_stack_disconnect();      // 让主机看到拔出
USBX_MSC_Resume();                 // 重新注册 MSC
HAL_PCD_Start(...) 或 ux_device_stack_connect();  // 重新上线，主机会当新插入的盘
```

---

**User**

好的，我准备采纳 方案 1：让主机看到真正的“介质变更” (不强制断总线，CDC 可保持) 进行测试，方案1电脑重读的时候，是不是还会调用到 @USBX/App/ux_device_msc.c:349-389 函数，但 USBD_SD_CardInfo 的信息我只在首测STM32启动时在 main @Core/Src/main.c:147 执行过一次，但测速例程 @APP/app_demo_sd_filex.c:651 @APP/app_demo_sd_filex.c:681 完成后会保留创建的 "Speed%02d.txt"文件

---

**Cursor**

方案 1 不需要改 `USBD_SD_CardInfo`，也不要求重新调用 `HAL_SD_GetCardInfo`，因为卡的几何（LBA 数、BlockSize）没变，只是 FAT/目录被你改了。主机重读时用的还是上电时填入的容量，这没问题。你要做的是让主机收到 “介质已变更” 的 UNIT ATTENTION，并在首次访问时返回正确的 sense，让它重扫 FAT。

可以按下面步骤落地：

1) 增加两个标志（全局或静态）  
```c
volatile UINT g_media_present  = UX_TRUE;  // 介质在位
volatile UINT g_media_changed  = UX_FALSE; // 介质已变更（只报一次）
```

2) 测速流程中：  
- 进入测速前：`g_media_present = UX_FALSE;` （或保留你现在的暂停逻辑）  
- 测速结束后：`fx_file_close` → `fx_media_flush` → `fx_media_close`  
- 然后：  
```c
g_media_present = UX_TRUE;
g_media_changed = UX_TRUE;   // 告诉主机介质改过
```

3) 在 `USBD_STORAGE_Status` 中处理：  
```c
UINT USBD_STORAGE_Status(..., ULONG *media_status)
{
    ...
    if (g_media_present == UX_FALSE) {
        *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00); // NOT READY / MEDIUM NOT PRESENT
        return UX_SUCCESS; // 避免 STALL
    }

    if (g_media_changed == UX_TRUE) {
        *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00); // UNIT ATTENTION / MEDIUM MAY HAVE CHANGED
        g_media_changed = UX_FALSE; // 只报一次
        return UX_SUCCESS; // 让主机自行重读 FAT
    }

    *media_status = 0;
    return UX_SUCCESS;
}
```

4) 在 `USBD_STORAGE_Read/Write` 里也参考这个逻辑：  
- 若 `g_media_present == UX_FALSE`，返回 `UX_SUCCESS` + 上述 “NOT PRESENT” sense（避免 STALL）；  
- 若 `g_media_changed == UX_TRUE`，同样返回 `UX_SUCCESS` + “MEDIUM MAY HAVE CHANGED”，并清标志；  
- 正常路径再执行 DMA。这样主机会在第一次访问时就收到介质变更，不会继续用旧缓存。

5) 不必改 `USBD_STORAGE_GetMediaLastLba/Blocklength`，除非你在运行中真的变更了分区或卡（通常不会）。文件 `Speed%02d.txt` 留在卡上没问题，只要已经 flush/close，主机重扫 FAT 就能看到。

这样做后，CDC 不会断线，主机会在你设回 `g_media_present=UX_TRUE` 后自动重新读 FAT/目录，盘符不会再变成 G:?。

```c
volatile UINT g_media_present  = UX_TRUE;  // 介质在位
volatile UINT g_media_changed  = UX_FALSE; // 介质已变更（只报一次）
```

```c
g_media_present = UX_TRUE;
g_media_changed = UX_TRUE;   // 告诉主机介质改过
```

```c
UINT USBD_STORAGE_Status(..., ULONG *media_status)
{
    ...
    if (g_media_present == UX_FALSE) {
        *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00); // NOT READY / MEDIUM NOT PRESENT
        return UX_SUCCESS; // 避免 STALL
    }

    if (g_media_changed == UX_TRUE) {
        *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00); // UNIT ATTENTION / MEDIUM MAY HAVE CHANGED
        g_media_changed = UX_FALSE; // 只报一次
        return UX_SUCCESS; // 让主机自行重读 FAT
    }

    *media_status = 0;
    return UX_SUCCESS;
}
```

---

**User**

我已经在USBD_xxxx_xxx函数中添加了修改，测速完毕后，还会变为是G:? @ux_device_msc.c 

---

**Cursor**


`g_media_changed` 在第一次调用时就被清除了，Windows 可能还没开始重读 FAT。另外，Windows 可能需要在多个命令（如 Test Unit Ready、Read Capacity）中都收到“介质已变更”才会真正刷新缓存。

建议修改：



问题在于 `g_media_changed` 在第一次调用时就被清除，Windows 可能还没开始重读 FAT。另外，Windows 可能需要在多个命令中都收到“介质已变更”才会真正刷新缓存。

建议修改：让 `g_media_changed` 持续一段时间，而不是立即清除。


```c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    ux_device_msc.c
  * @author  MCD Application Team
  * @brief   USBX Device MSC applicative source file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2020-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/* Includes ------------------------------------------------------------------*/
#include "ux_device_msc.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "sdmmc.h"
#include "main.h"
#include "fx_stm32_sd_driver.h"
#include "app_usbx_device.h"   //!< 提供 EventFlagMsc
#include "app_filex.h"

#include "ux_api.h"
#include "ux_device_stack.h"
#include "ux_device_class_storage.h"
#include "ux_device_class_storage.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define MEDIA_STATUS_OK           0u
#define MEDIA_STATUS_NOT_PRESENT  1u
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
#define SD_READ_FLAG   0x01
#define SD_WRITE_FLAG  0x02
#define SD_TIMEOUT     100U
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */
static int32_t check_sd_status(VOID);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
volatile UINT g_media_present = UX_TRUE; //介质已移除的标志
volatile UINT g_media_changed  = UX_FALSE; // 介质已变更（只报一次）
volatile UINT g_media_changed_count = 0U; // 介质变更通知计数（让 Windows 多次收到 UNIT ATTENTION）

VOID ux_app_msc_media_eject(VOID)
{
    g_media_present = UX_FALSE;
}
/* USER CODE END 0 */

/**
  * @brief  USBD_STORAGE_Activate
  *         This function is called when insertion of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Activate(VOID *storage_instance)
{
  /* USER CODE BEGIN USBD_STORAGE_Activate */
  UX_PARAMETER_NOT_USED(storage_instance);

  /* USER CODE END USBD_STORAGE_Activate */

  return;
}

/**
  * @brief  USBD_STORAGE_Deactivate
  *         This function is called when extraction of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Deactivate(VOID *storage_instance)
{
  /* USER CODE BEGIN USBD_STORAGE_Desactivate */
  UX_PARAMETER_NOT_USED(storage_instance);
  /* USER CODE END USBD_STORAGE_Desactivate */

  return;
}

/**
  * @brief  USBD_STORAGE_Read
  *         This function is invoked to read from media.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  data_pointer: Address of the buffer to be used for reading or writing.
  * @param  number_blocks: number of sectors to read/write.
  * @param  lba: Logical block address is the sector address to read.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Read(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                       ULONG number_blocks, ULONG lba, ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Read */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_status);

  // 介质已移除状态：返回“成功但带错误感知”
  if (g_media_present == UX_FALSE) {
      // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
      *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
      return status;  // 返回成功，避免上层 STALL
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    g_media_changed = UX_FALSE;
    return status;
  }

  // 介质未移除状态

  ULONG ReadFlags = 0U;

  /* Check if the SD card is present */
//  if (HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5) != GPIO_PIN_RESET)
//  {
    /* Check id SD card is ready */
    if(check_sd_status() != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    /* Start the Dma write */
    status =  HAL_SD_ReadBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);
    if(status != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

// 不需要缓存维护API，访问的是AXISRAM2区域
//#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
//    invalidate_cache_by_addr((uint32_t*)data_pointer, number_blocks * FX_STM32_SD_DEFAULT_SECTOR_SIZE);
//#endif

    /* Wait on readflag until SD card is ready to use for new operation */
    if (tx_event_flags_get(&EventFlagMsc, SD_READ_FLAG, TX_OR_CLEAR,
                           &ReadFlags, TX_WAIT_FOREVER) != TX_SUCCESS)
    {
      _Error_Handler(__FILE__, __LINE__);
    }
//  }

  /* USER CODE END USBD_STORAGE_Read */

  return status;
}

/**
  * @brief  USBD_STORAGE_Write
  *         This function is invoked to write in media.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  data_pointer: Address of the buffer to be used for reading or writing.
  * @param  number_blocks: number of sectors to read/write.
  * @param  lba: Logical block address is the sector address to read.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Write(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                        ULONG number_blocks, ULONG lba, ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Write */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_status);

  // 介质已移除状态：返回“成功但带错误感知”
  if (g_media_present == UX_FALSE) {
      // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
      *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
      return status;  // 返回成功，避免上层 STALL
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    g_media_changed = UX_FALSE;
    return status;
  }

  // 介质未移除状态
  ULONG WriteFlags = 0U;

  /* Check if the SD card is present */
//  if (HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5) != GPIO_PIN_RESET)
//  {
    /* Check if SD card is ready */
    if(check_sd_status() != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

// 不需要缓存维护API，访问的是AXISRAM2区域
//#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
//    clean_cache_by_addr((uint32_t*)data_pointer, number_blocks * FX_STM32_SD_DEFAULT_SECTOR_SIZE);
//#endif

    /* Start the Dma write */
    status = HAL_SD_WriteBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);

    if(status != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    /* Wait on writeflag until SD card is ready to use for new operation */
    if (tx_event_flags_get(&EventFlagMsc, SD_WRITE_FLAG, TX_OR_CLEAR,
                           &WriteFlags, TX_WAIT_FOREVER) != TX_SUCCESS)
    {
      _Error_Handler(__FILE__, __LINE__);
    }
//  }

  /* USER CODE END USBD_STORAGE_Write */

  return status;
}

/**
  * @brief  USBD_STORAGE_Flush
  *         This function is invoked to flush media.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  number_blocks: number of sectors to read/write.
  * @param  lba: Logical block address is the sector address to read.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Flush(VOID *storage_instance, ULONG lun, ULONG number_blocks,
                        ULONG lba, ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Flush */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(number_blocks);
  UX_PARAMETER_NOT_USED(lba);
  UX_PARAMETER_NOT_USED(media_status);

  // 介质已移除状态：返回“成功但带错误感知”
  if (g_media_present == UX_FALSE) {
      // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
      *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
      return status;  // 返回成功，避免上层 STALL
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    g_media_changed = UX_FALSE;
    return status;
  }

  // 介质未移除状态

  /* USER CODE END USBD_STORAGE_Flush */

  return status;
}

/**
  * @brief  USBD_STORAGE_Status
  *         This function is invoked to obtain the status of the device.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  media_id: is not currently used.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Status */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_id);
  UX_PARAMETER_NOT_USED(media_status);
  // 此函数在 MSC U盘挂载在windows时，会被一直定期调用
  if (g_media_present == UX_FALSE) {
	  *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
    return status;        // 让主机认为介质不在
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    g_media_changed = UX_FALSE;
    return status;
  }
  /* USER CODE END USBD_STORAGE_Status */

  return status;
}

/**
  * @brief  USBD_STORAGE_Notification
  *         This function is invoked to obtain the notification of the device.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  media_id: is not currently used.
  * @param  notification_class: specifies the class of notification.
  * @param  media_notification: response for the notification.
  * @param  media_notification_length: length of the response buffer.
  * @retval status
  */
UINT USBD_STORAGE_Notification(VOID *storage_instance, ULONG lun, ULONG media_id,
                               ULONG notification_class, UCHAR **media_notification,
                               ULONG *media_notification_length)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Notification */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_id);
  UX_PARAMETER_NOT_USED(notification_class);
  UX_PARAMETER_NOT_USED(media_notification);
  UX_PARAMETER_NOT_USED(media_notification_length);

  /* USER CODE END USBD_STORAGE_Notification */

  return status;
}

/**
  * @brief  USBD_STORAGE_GetMediaLastLba
  *         Get Media last LBA.
  * @param  none
  * @retval last lba
  */
ULONG USBD_STORAGE_GetMediaLastLba(VOID)
{
  ULONG LastLba = 0U;

  /* USER CODE BEGIN USBD_STORAGE_GetMediaLastLba */
#if 1
  LastLba = (ULONG)(USBD_SD_CardInfo.BlockNbr - 1);
#else // 等价写法
  LastLba = (ULONG)(hsd2.SdCard.BlockNbr -1);
#endif
  /* USER CODE END USBD_STORAGE_GetMediaLastLba */

  return LastLba;
}

/**
  * @brief  USBD_STORAGE_GetMediaBlocklength
  *         Get Media block length.
  * @param  none.
  * @retval block length.
  */
ULONG USBD_STORAGE_GetMediaBlocklength(VOID)
{
  ULONG MediaBlockLen = 0U;

  /* USER CODE BEGIN USBD_STORAGE_GetMediaBlocklength */
#if 1
  MediaBlockLen = (ULONG) USBD_SD_CardInfo.BlockSize;
#else // 等价写法
  MediaBlockLen = (ULONG) hsd2.SdCard.BlockSize;
#endif
  /* USER CODE END USBD_STORAGE_GetMediaBlocklength */

  return MediaBlockLen;
}

/* USER CODE BEGIN 2 */

/**
  * @brief  check_sd_status
  *         check SD card Transfer Status.
  * @param  none
  * @retval BSP status
  */
static int32_t check_sd_status(VOID)
{

  uint32_t start = tx_time_get();

  while (tx_time_get() - start < SD_TIMEOUT)
  {
    if (HAL_SD_GetCardState(&hsd2) == HAL_SD_CARD_TRANSFER)
    {
      return HAL_OK;
    }
  }

  return HAL_ERROR;
}

/* USER CODE END 2 */

```

```c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    ux_device_msc.c
  * @author  MCD Application Team
  * @brief   USBX Device MSC applicative source file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2020-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/* Includes ------------------------------------------------------------------*/
#include "ux_device_msc.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "sdmmc.h"
#include "main.h"
#include "fx_stm32_sd_driver.h"
#include "app_usbx_device.h"   //!< 提供 EventFlagMsc
#include "app_filex.h"

#include "ux_api.h"
#include "ux_device_stack.h"
#include "ux_device_class_storage.h"
#include "ux_device_class_storage.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define MEDIA_STATUS_OK           0u
#define MEDIA_STATUS_NOT_PRESENT  1u
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
#define SD_READ_FLAG   0x01
#define SD_WRITE_FLAG  0x02
#define SD_TIMEOUT     100U
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */
static int32_t check_sd_status(VOID);

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
volatile UINT g_media_present = UX_TRUE; //介质已移除的标志
volatile UINT g_media_changed  = UX_FALSE; // 介质已变更（只报一次）
volatile UINT g_media_changed_count = 0U; // 介质变更通知计数（让 Windows 多次收到 UNIT ATTENTION）

VOID ux_app_msc_media_eject(VOID)
{
    g_media_present = UX_FALSE;
}
/* USER CODE END 0 */

/**
  * @brief  USBD_STORAGE_Activate
  *         This function is called when insertion of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Activate(VOID *storage_instance)
{
  /* USER CODE BEGIN USBD_STORAGE_Activate */
  UX_PARAMETER_NOT_USED(storage_instance);

  /* USER CODE END USBD_STORAGE_Activate */

  return;
}

/**
  * @brief  USBD_STORAGE_Deactivate
  *         This function is called when extraction of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Deactivate(VOID *storage_instance)
{
  /* USER CODE BEGIN USBD_STORAGE_Desactivate */
  UX_PARAMETER_NOT_USED(storage_instance);
  /* USER CODE END USBD_STORAGE_Desactivate */

  return;
}

/**
  * @brief  USBD_STORAGE_Read
  *         This function is invoked to read from media.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  data_pointer: Address of the buffer to be used for reading or writing.
  * @param  number_blocks: number of sectors to read/write.
  * @param  lba: Logical block address is the sector address to read.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Read(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                       ULONG number_blocks, ULONG lba, ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Read */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_status);

  // 介质已移除状态：返回“成功但带错误感知”
  if (g_media_present == UX_FALSE) {
      // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
      *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
      return status;  // 返回成功，避免上层 STALL
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    // 让 Windows 收到多次 UNIT ATTENTION 才清除标志，确保它重读 FAT
    g_media_changed_count++;
    if (g_media_changed_count >= 3) {  // 返回 3 次后清除
      g_media_changed = UX_FALSE;
      g_media_changed_count = 0U;
    }
    return status;
  }

  // 介质未移除状态

  ULONG ReadFlags = 0U;

  /* Check if the SD card is present */
//  if (HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5) != GPIO_PIN_RESET)
//  {
    /* Check id SD card is ready */
    if(check_sd_status() != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    /* Start the Dma write */
    status =  HAL_SD_ReadBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);
    if(status != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

// 不需要缓存维护API，访问的是AXISRAM2区域
//#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
//    invalidate_cache_by_addr((uint32_t*)data_pointer, number_blocks * FX_STM32_SD_DEFAULT_SECTOR_SIZE);
//#endif

    /* Wait on readflag until SD card is ready to use for new operation */
    if (tx_event_flags_get(&EventFlagMsc, SD_READ_FLAG, TX_OR_CLEAR,
                           &ReadFlags, TX_WAIT_FOREVER) != TX_SUCCESS)
    {
      _Error_Handler(__FILE__, __LINE__);
    }
//  }

  /* USER CODE END USBD_STORAGE_Read */

  return status;
}

/**
  * @brief  USBD_STORAGE_Write
  *         This function is invoked to write in media.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  data_pointer: Address of the buffer to be used for reading or writing.
  * @param  number_blocks: number of sectors to read/write.
  * @param  lba: Logical block address is the sector address to read.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Write(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                        ULONG number_blocks, ULONG lba, ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Write */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_status);

  // 介质已移除状态：返回“成功但带错误感知”
  if (g_media_present == UX_FALSE) {
      // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
      *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
      return status;  // 返回成功，避免上层 STALL
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    // 让 Windows 收到多次 UNIT ATTENTION 才清除标志，确保它重读 FAT
    g_media_changed_count++;
    if (g_media_changed_count >= 3) {  // 返回 3 次后清除
      g_media_changed = UX_FALSE;
      g_media_changed_count = 0U;
    }
    return status;
  }

  // 介质未移除状态
  ULONG WriteFlags = 0U;

  /* Check if the SD card is present */
//  if (HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5) != GPIO_PIN_RESET)
//  {
    /* Check if SD card is ready */
    if(check_sd_status() != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

// 不需要缓存维护API，访问的是AXISRAM2区域
//#if (FX_STM32_SD_CACHE_MAINTENANCE == 1)
//    clean_cache_by_addr((uint32_t*)data_pointer, number_blocks * FX_STM32_SD_DEFAULT_SECTOR_SIZE);
//#endif

    /* Start the Dma write */
    status = HAL_SD_WriteBlocks_DMA(&hsd2, data_pointer, lba, number_blocks);

    if(status != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    /* Wait on writeflag until SD card is ready to use for new operation */
    if (tx_event_flags_get(&EventFlagMsc, SD_WRITE_FLAG, TX_OR_CLEAR,
                           &WriteFlags, TX_WAIT_FOREVER) != TX_SUCCESS)
    {
      _Error_Handler(__FILE__, __LINE__);
    }
//  }

  /* USER CODE END USBD_STORAGE_Write */

  return status;
}

/**
  * @brief  USBD_STORAGE_Flush
  *         This function is invoked to flush media.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  number_blocks: number of sectors to read/write.
  * @param  lba: Logical block address is the sector address to read.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Flush(VOID *storage_instance, ULONG lun, ULONG number_blocks,
                        ULONG lba, ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Flush */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(number_blocks);
  UX_PARAMETER_NOT_USED(lba);
  UX_PARAMETER_NOT_USED(media_status);

  // 介质已移除状态：返回“成功但带错误感知”
  if (g_media_present == UX_FALSE) {
      // 填标准 SENSE：NOT READY / MEDIUM NOT PRESENT
      *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
      return status;  // 返回成功，避免上层 STALL
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    // 让 Windows 收到多次 UNIT ATTENTION 才清除标志，确保它重读 FAT
    g_media_changed_count++;
    if (g_media_changed_count >= 3) {  // 返回 3 次后清除
      g_media_changed = UX_FALSE;
      g_media_changed_count = 0U;
    }
    return status;
  }

  // 介质未移除状态

  /* USER CODE END USBD_STORAGE_Flush */

  return status;
}

/**
  * @brief  USBD_STORAGE_Status
  *         This function is invoked to obtain the status of the device.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  media_id: is not currently used.
  * @param  media_status: should be filled out exactly like the media status
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Status */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_id);
  UX_PARAMETER_NOT_USED(media_status);
  // 此函数在 MSC U盘挂载在windows时，会被一直定期调用
  if (g_media_present == UX_FALSE) {
	  *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02, 0x3A, 0x00);
    return status;        // 让主机认为介质不在
  }
  if (g_media_changed == UX_TRUE) {
    *media_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x06, 0x28, 0x00);
    // 让 Windows 收到多次 UNIT ATTENTION 才清除标志，确保它重读 FAT
    g_media_changed_count++;
    if (g_media_changed_count >= 3) {  // 返回 3 次后清除
      g_media_changed = UX_FALSE;
      g_media_changed_count = 0U;
    }
    return status;
  }
  /* USER CODE END USBD_STORAGE_Status */

  return status;
}

/**
  * @brief  USBD_STORAGE_Notification
  *         This function is invoked to obtain the notification of the device.
  * @param  storage_instance : Pointer to the storage class instance.
  * @param  lun: Logical unit number is the command is directed to.
  * @param  media_id: is not currently used.
  * @param  notification_class: specifies the class of notification.
  * @param  media_notification: response for the notification.
  * @param  media_notification_length: length of the response buffer.
  * @retval status
  */
UINT USBD_STORAGE_Notification(VOID *storage_instance, ULONG lun, ULONG media_id,
                               ULONG notification_class, UCHAR **media_notification,
                               ULONG *media_notification_length)
{
  UINT status = UX_SUCCESS;

  /* USER CODE BEGIN USBD_STORAGE_Notification */
  UX_PARAMETER_NOT_USED(storage_instance);
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_id);
  UX_PARAMETER_NOT_USED(notification_class);
  UX_PARAMETER_NOT_USED(media_notification);
  UX_PARAMETER_NOT_USED(media_notification_length);

  /* USER CODE END USBD_STORAGE_Notification */

  return status;
}

/**
  * @brief  USBD_STORAGE_GetMediaLastLba
  *         Get Media last LBA.
  * @param  none
  * @retval last lba
  */
ULONG USBD_STORAGE_GetMediaLastLba(VOID)
{
  ULONG LastLba = 0U;

  /* USER CODE BEGIN USBD_STORAGE_GetMediaLastLba */
#if 1
  LastLba = (ULONG)(USBD_SD_CardInfo.BlockNbr - 1);
#else // 等价写法
  LastLba = (ULONG)(hsd2.SdCard.BlockNbr -1);
#endif
  /* USER CODE END USBD_STORAGE_GetMediaLastLba */

  return LastLba;
}

/**
  * @brief  USBD_STORAGE_GetMediaBlocklength
  *         Get Media block length.
  * @param  none.
  * @retval block length.
  */
ULONG USBD_STORAGE_GetMediaBlocklength(VOID)
{
  ULONG MediaBlockLen = 0U;

  /* USER CODE BEGIN USBD_STORAGE_GetMediaBlocklength */
#if 1
  MediaBlockLen = (ULONG) USBD_SD_CardInfo.BlockSize;
#else // 等价写法
  MediaBlockLen = (ULONG) hsd2.SdCard.BlockSize;
#endif
  /* USER CODE END USBD_STORAGE_GetMediaBlocklength */

  return MediaBlockLen;
}

/* USER CODE BEGIN 2 */

/**
  * @brief  check_sd_status
  *         check SD card Transfer Status.
  * @param  none
  * @retval BSP status
  */
static int32_t check_sd_status(VOID)
{

  uint32_t start = tx_time_get();

  while (tx_time_get() - start < SD_TIMEOUT)
  {
    if (HAL_SD_GetCardState(&hsd2) == HAL_SD_CARD_TRANSFER)
    {
      return HAL_OK;
    }
  }

  return HAL_ERROR;
}

/* USER CODE END 2 */

```


已修改：`g_media_changed` 会在返回 3 次 UNIT ATTENTION 后才清除，让 Windows 有更多机会收到“介质已变更”信号。

如果仍出现 `G:?`，可尝试：

1. 在测速完成后延迟恢复


```c
/**
  ******************************************************************************
  * @file        app_demo_sd_filex.c
  * @author      安富莱电子 www.armfly.com
  * @created on  2025年12月3日
  * @brief       
  ******************************************************************************
  * @attention
  *
  * Copyright (C), 2021-2030, 安富莱电子 www.armfly.com
  *
  * @attention
  *           本文件代码片段源于安富莱电子（www.armfly.com）开源示例工程
  *           OldGerman 对其原始文件进行修改后使用
  *
  *	模块名称 : SD卡Fat文件系统和SD卡模拟演示模块。
  *	文件名称 : demo_sd_filex.c
  *	版    本 : V1.0
  *	说    明 : 演示如何创建文件、读取文件、创建目录和删除文件
  *			   并测试了文件读写速度.支持以下6个功能，用户通过电脑端
  *			   串口软件发送数字给开发板即可:
  *              1 - 显示根目录下的文件列表
  *              2 - 创建一个新文件armfly.txt
  *              3 - 读armfly.txt文件的内容
  *              4 - 创建目录
  *              5 - 删除文件和目录
  *              6 - 读写文件速度测试
  *              a - 打开SD卡模拟U盘
  *              b - 关闭SD卡模拟U盘
  *
  * 版    本 : V2.0
  * 说    明 : 将每一个测试函数执行后，变为后台线程只运行一次后结束
  *
  *              另外注意，SD卡模拟U盘是用的MicroUSB接口。
  *	修改记录 :
  *		版本号   日期         作者        说明
  *		V1.0    2021-01-30   Eric2013    正式发布
  *		V2.0    2025-12--3   OldGerman   改为ThreadX单次任务
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
//#include "includes.h"
#include "stdint.h"
#include  <stdarg.h>
#include  <stdio.h>
#include  <stdlib.h>
#include  <math.h>
#include "sdmmc.h"
#include "tx_api.h"
#include "tx_timer.h"
#include "fx_api.h"
#include "app_filex.h"
#include "fx_stm32_sd_driver.h"
#include "app_usbx_device.h"
#include "ux_device_msc.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define bsp_GetRunTime          tx_time_get

/* Private macro -------------------------------------------------------------*/
/* 用于测试读写速度 */
#define TEST_FILE_LEN			(2*1024*1024)	/* 用于测试的文件长度 */
#define BUF_SIZE				(32*1024)		/* 每次读写SD卡的最大数据长度 */

/* Exported constants --------------------------------------------------------*/
/* Private constants ---------------------------------------------------------*/
/* Exported variables --------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* 测试所用静态内存 */
__attribute__((section(".axisram2_bss"), aligned(32)))
uint32_t media_memory[16*1024];
ALIGN_32BYTES (char FsReadBuf[1024]);
ALIGN_32BYTES (char FsWriteBuf[1024]) = {"ThreadX FileX Write Demo \r\n www.armfly.com \r\n"};
//ALIGN_32BYTES (uint8_t g_TestBuf[BUF_SIZE]);
//__attribute__((section(".axisram2_bss"), aligned(32))) char FsReadBuf[1024];
//__attribute__((section(".axisram2_data"), aligned(32), used)) char FsWriteBuf[1024] = {"ThreadX FileX Write Demo \r\n www.armfly.com \r\n"};
//__attribute__((section(".axisram2_bss"), aligned(32))) uint8_t g_TestBuf[BUF_SIZE];
__attribute__((section(".sram1_bss"), aligned(32))) uint8_t g_TestBuf[BUF_SIZE];

/* FileX相关变量 */
FX_FILE      fx_file;
CHAR         entry_name[FX_MAX_LONG_NAME_LEN];

/* Private function prototypes -----------------------------------------------*/
static void DispMenu(void);
static void ViewRootDir(void);
static void CreateNewFile(void);
static void ReadFileData(void);
static void CreateDir(void);
static void DeleteDirFile(void);
void fxSdTestSpeed(void);

/* Function implementations --------------------------------------------------*/



/*
*********************************************************************************************************
*	函 数 名: DemoFatFS
*	功能说明: FatFS文件系统演示主程序
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/

void DemoFileX(void)
{
  fxSdTestSpeed();
//switch()
//	case'0':
//	DispMenu();
//	break;
//	case '1':
//	printf("【1 - ViewRootDir】\r\n");
//	ViewRootDir();		/* 显示SD卡根目录下的文件名 */
//	break;
//
//	case '2':
//	printf("【2 - CreateNewFile】\r\n");
//	CreateNewFile();	/* 创建一个新文件,写入一个字符串 */
//	break;
//
//	case '3':
//	printf("【3 - ReadFileData】\r\n");
//	ReadFileData();		/* 读取根目录下armfly.txt的内容 */
//	break;
//
//	case '4':
//	printf("【4 - CreateDir】\r\n");
//	CreateDir();		/* 创建目录 */
//	break;
//
//	case '5':
//	printf("【5 - DeleteDirFile】\r\n");
//	DeleteDirFile();	/* 删除目录和文件 */
//	break;
//
//	case '6':
//	printf("【6 - TestSpeed】\r\n");
//	WriteFileTest();	/* 速度测试 */
//	break;
//
//	default:
//
//	break;
}

/*
*********************************************************************************************************
*	函 数 名: DispMenu
*	功能说明: 显示操作提示菜单
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void DispMenu(void)
{
	printf("\r\n------------------------------------------------\r\n");
	printf("请选择操作命令，打开SD卡模拟U盘操作期间不支持再调用命令1-6:\r\n");
	printf("1 - 显示根目录下的文件列表\r\n");
	printf("2 - 创建一个新文件armfly.txt\r\n");
	printf("3 - 读armfly.txt文件的内容\r\n");
	printf("4 - 创建目录\r\n");
	printf("5 - 删除文件和目录\r\n");
	printf("6 - 读写文件速度测试\r\n");
}

/*
*********************************************************************************************************
*	函 数 名: ViewRootDir
*	功能说明: 显示SD卡根目录下的文件名
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
extern SD_HandleTypeDef hsd2;
static void ViewRootDir(void)
{
    UINT status;
    UINT attributes;
    ULONG size;
    UINT year;
    UINT month;
    UINT day;
    UINT hour;
    UINT minute;
    UINT second;
    UINT cnt;
    ULONG64 available_bytes;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }


    printf("属性        |  文件大小 | 短文件名 | 长文件名\r\n");
	for (cnt = 0; ;cnt++)
	{
        /* 读取目录项，索引会自动下移 */
        status = fx_directory_next_full_entry_find(&sdio_disk,
                                                    entry_name,
                                                    &attributes,
                                                    &size,
                                                    &year, &month, &day,
                                                    &hour, &minute, &second);

        if (status != FX_SUCCESS || entry_name[0] == 0)
		{
			break;
		}

		if (entry_name[0] == '.')
		{
			continue;
		}

		/* 判断是文件还是子目录 */
		if (attributes & FX_DIRECTORY)
		{
			printf("目录  ");
		}
		else
		{
			printf("文件  ");
		}

		/* 打印文件大小, 最大4G */
		printf(" %10d", (int)size);


		printf("  %s\r\n", (char *)entry_name);	/* 长文件名 */
	}

    /* SD卡剩余容量大小 */
    status = fx_media_extended_space_available(&sdio_disk, &available_bytes);

    if (status == FX_SUCCESS)
    {
        printf("SD卡剩余容量大小 -- %lldMB\r\n", available_bytes/1024/1024);
    }

    /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: CreateNewFile
*	功能说明: 在SD卡创建一个新文件，文件内容填写“www.armfly.com”
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void CreateNewFile(void)
{
    UINT status;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 创建文件 */
    status =  fx_file_create(&sdio_disk, "armfly.txt");

    /* 检测状态 */
    if (status != FX_SUCCESS)
    {
        /* 失败的话，可以考虑二次创建 */
        if (status != FX_ALREADY_CREATED)
        {
            printf("创建文件失败\r\n");
        }
    }

    /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, "armfly.txt", FX_OPEN_FOR_WRITE);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }


    /* 写入字符串到文件  */
    status =  fx_file_write(&fx_file, FsWriteBuf, strlen(FsWriteBuf));

    if (status == FX_SUCCESS)
    {
        printf("armfly.txt 文件写入成功\r\n");
    }
    else
    {
        printf("armfly.txt 文件写入失败 %d\r\n", status);
    }

    /* 关闭文件  */
    status =  fx_file_close(&fx_file);

    /* Check the file close status.  */
    if (status != FX_SUCCESS)
    {
        printf("关闭文件失败\r\n");
    }

    /* 保证文件写入全部生效 */
    status = fx_media_flush(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("flush失败\r\n");
    }

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: ReadFileData
*	功能说明: 读取文件armfly.txt前128个字符，并打印到串口
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ReadFileData(void)
{
    UINT status;
    ULONG bw;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }


    /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, "armfly.txt", FX_OPEN_FOR_READ);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }

    /*  */
    status =  fx_file_read(&fx_file, FsReadBuf, sizeof(FsReadBuf), &bw);

    printf("--%sReadLen = %d\r\n", FsReadBuf, (int)bw);

    if ((status != FX_SUCCESS))
    {
        printf("读取失败\r\n");
    }

    /* 关闭文件  */
    status =  fx_file_close(&fx_file);

    if (status != FX_SUCCESS)
    {
        printf("关闭文件失败\r\n");
    }

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: CreateDir
*	功能说明: 在SD卡根目录创建Dir1和Dir2目录，在Dir1目录下创建子目录Dir1_1
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void CreateDir(void)
{
    UINT status;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 创建目录/Dir1 */
    status = fx_directory_create(&sdio_disk, "Dir1");

    if (status == FX_SUCCESS)
    {
        printf("文件夹Dir1创建成功\r\n");
    }
	else if (status == FX_ALREADY_CREATED)
	{
		printf("Dir1 目录已经存在(%d)\r\n", status);
	}
	else
	{
		printf("fx_directory_create Dir1 失败 (%d)\r\n", status);
		return;
	}

	/* 创建目录/Dir2 */
    status = fx_directory_create(&sdio_disk, "Dir2");

    if (status == FX_SUCCESS)
    {
        printf("文件夹Dir2创建成功\r\n");
    }
	else if (status == FX_ALREADY_CREATED)
	{
		printf("Dir2 目录已经存在(%d)\r\n", status);
	}
	else
	{
		printf("fx_directory_create Dir2 失败 (%d)\r\n", status);
		return;
	}

	/* 创建子目录 /Dir1/Dir1_1	   注意：创建子目录Dir1_1时，必须先创建好Dir1 ？ */
    status = fx_directory_create(&sdio_disk, "Dir1/Dir1_1");

    if (status == FX_SUCCESS)
    {
        printf("文件夹Dir1/Dir1_1创建成功\r\n");
    }
	else if (status == FX_ALREADY_CREATED)
	{
		printf("Dir1/Dir1_1 目录已经存在(%d)\r\n", status);
	}
	else
	{
		printf("fx_directory_create Dir1/Dir1_1 失败 (%d)\r\n", status);
		return;
	}

    /* 保证文件写入全部生效 */
    status = fx_media_flush(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("flush失败\r\n");
    }

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: DeleteDirFile
*	功能说明: 删除SD卡根目录下的 armfly.txt 文件和 Dir1，Dir2 目录
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void DeleteDirFile(void)
{
    UINT status;
    UINT i;
    char path[50];


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 删除目录/Dir1 【因为还存在目录非空（存在子目录)，所以这次删除会失败】*/
    status = fx_directory_delete(&sdio_disk, "Dir1");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir1成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "/Dir1");
	}
	else
	{
		printf("删除Dir1失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}


 	/* 先删除目录/Dir1/Dir1_1 */
    status = fx_directory_delete(&sdio_disk, "Dir1/Dir1_1");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir1/Dir1_1成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "Dir1/Dir1_1");
	}
	else
	{
		printf("删除Dir1/Dir1_1失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

    /* 删除目录/Dir1*/
    status = fx_directory_delete(&sdio_disk, "Dir1");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir1成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "Dir1");
	}
	else
	{
		printf("删除Dir1失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

    /* 删除目录/Dir2*/
    status = fx_directory_delete(&sdio_disk, "Dir2");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir2成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "Dir2");
	}
	else
	{
		printf("删除Dir2失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

	/* 删除文件 armfly.txt */
    status = fx_file_delete(&sdio_disk, "armfly.txt");

    if (status == FX_SUCCESS)
	{
		printf("删除目录armfly.txt成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "armfly.txt");
	}
	else
	{
		printf("删除armfly.txt失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

	/* 删除文件 speed1.txt */
	for (i = 0; i < 20; i++)
	{
		sprintf(path, "Speed%02d.txt", i);/* 每写1次，序号递增 */

        status = fx_file_delete(&sdio_disk, path);

        if (status == FX_SUCCESS)
        {
            printf("删除文件%s成功\r\n", path);
        }
        else if (status == FX_NOT_FOUND)
        {
            printf("没有发现文件:%s\r\n", path);
        }
        else
        {
            printf("删除%s文件失败(错误代码 = %d) 文件只读或目录非空\r\n", path, status);
        }
	}

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}


/*
*********************************************************************************************************
*	函 数 名: WriteFileTest
*	功能说明: 测试文件读写速度
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void fxSdTestSpeed(void)
{
    UINT status;
    char path[64];

    ULONG bw;
	uint32_t i,k;
	uint32_t runtime1,runtime2,timelen;
	uint8_t err = 0;
	static uint8_t s_ucTestSn = 0;

	g_media_present = UX_FALSE; // PC 先弹出 U盘:
//	status = USBX_MSC_Pause();

	for (i = 0; i < sizeof(g_TestBuf); i++)
	{
		g_TestBuf[i] = (i / 512) + '0';
	}


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 打开文件 */
	sprintf(path, "Speed%02d.txt", s_ucTestSn++); /* 每写1次，序号递增 */

    /* 写一串数据 */
	printf("开始写文件%s %dKB ...\r\n", path, TEST_FILE_LEN / 1024);

    /* 创建文件 */
    status =  fx_file_create(&sdio_disk, path);

    /* 检测状态 */
    if (status != FX_SUCCESS)
    {
        /* 失败的话，可以考虑二次创建 */
        if (status != FX_ALREADY_CREATED)
        {
            printf("创建文件失败\r\n");
        }
    }

    /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, path, FX_OPEN_FOR_WRITE);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }

    runtime1 = bsp_GetRunTime();	/* 读取系统运行时间 */
    for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
	{
        /* 写入字符串到文件  */
        status =  fx_file_write(&fx_file, g_TestBuf, sizeof(g_TestBuf));

        if (status == FX_SUCCESS)
        {
            if (((i + 1) % 8) == 0)
			{
				printf(".");
			}
        }
        else
        {
            err = 1;
			printf("%s文件写失败\r\n", path);
			break;
        }
	}
	runtime2 = bsp_GetRunTime();	/* 读取系统运行时间 */

	if (err == 0)
	{
		timelen = (runtime2 - runtime1);
		printf("\r\n  写耗时 : %ldms   平均写速度 : %ldB/S (%ldKB/S)\r\n",
                timelen,
                (TEST_FILE_LEN * 1000) / timelen,
                ((TEST_FILE_LEN / 1024) * 1000) / timelen);
		//-Og 4366KB/s@10MHz, 7787KB/s@50MHz
	}

    /* 关闭文件  */
    status =  fx_file_close(&fx_file);

    /* Check the file close status.  */
    if (status != FX_SUCCESS)
    {
        printf("关闭文件失败\r\n");
    }

    /* 保证文件写入全部生效 */
    status = fx_media_flush(&sdio_disk);

    /* Check the file close status.  */
    if (status != FX_SUCCESS)
    {
        printf("fx_media_flush失败\r\n");
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /* 开始读文件测试 */
	printf("开始读文件 %dKB ...\r\n", TEST_FILE_LEN / 1024);

      /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, path, FX_OPEN_FOR_READ);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }

    runtime1 = bsp_GetRunTime();	/* 读取系统运行时间 */
    for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
	{
        /* 写入字符串到文件  */

        status =  fx_file_read(&fx_file, g_TestBuf, sizeof(g_TestBuf), &bw);
        if (status == FX_SUCCESS)
        {
        	if (((i + 1) % 8) == 0)
			{
				printf(".");
			}

			/* 比较写入的数据是否正确，此语句会导致读卡速度结果降低到 3.5MBytes/S */
			for (k = 0; k < sizeof(g_TestBuf); k++)
			{
				if (g_TestBuf[k] != (k / 512) + '0')
				{
				  	err = 1;
					printf("Speed1.txt 文件读成功，但是数据出错\r\n");
					break;
				}
			}
			if (err == 1)
			{
				break;
			}
        }
        else
        {
           	err = 1;
			printf("Speed1.txt 文件读失败\r\n");
			break;
        }
	}
	runtime2 = bsp_GetRunTime();	/* 读取系统运行时间 */

	if (err == 0)
	{
		timelen = (runtime2 - runtime1);
		printf("\r\n  读耗时 : %ldms   平均读速度 : %ldB/S (%ldKB/S)\r\n", timelen,
			(TEST_FILE_LEN * 1000) / timelen, ((TEST_FILE_LEN / 1024) * 1000) / timelen);
		//-Og 6.965KB/s@50MHz
	}

	/**
	 * 不能直接卸载SD卡，会导致USBX MSC无法访问SD卡
	 * https://forum.anfulai.cn/forum.php?mod=redirect&goto=findpost&ptid=124988&pid=311741&fromuid=47676
	 * 找到原因了，原有例程上面是直接卸载了SD卡，我注释掉之后应该要加上fx_file_close
	 */
     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);
//    status =  fx_file_close(&fx_file);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }

//    status = USBX_MSC_Resume();
    // 延迟一小段时间，确保 Windows 完全卸载卷
    tx_thread_sleep(100);  // 等待 100 ticks（根据你的系统 tick 频率调整）
    
    g_media_present = UX_TRUE; // 重新让电脑识别U盘
    g_media_changed = UX_TRUE; // 介质已变更（会返回多次 UNIT ATTENTION）
}

/***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/


```


已做两处修改：

1. **让 `g_media_changed` 持续返回多次 UNIT ATTENTION**：在 `USBD_STORAGE_Read/Write/Status` 中，`g_media_changed` 为真时返回 UNIT ATTENTION，并计数；累计 3 次后才清除标志。这样 Windows 有更多机会收到“介质已变更”信号。

2. **延迟恢复介质状态**：在测速完成后，延迟 100 ticks 再设置 `g_media_present = UX_TRUE`，给 Windows 时间完全卸载卷。

如果仍出现 `G:?`，可尝试：

**方案 3：在 READ CAPACITY 中也返回 UNIT ATTENTION**

修改 `ux_device_class_storage_read_capacity.c`，在调用 `media_status` 时也检查 `g_media_changed`。但需要修改库文件，可能不太合适。

**方案 4：强制重新枚举 MSC（CDC 会短暂断开）**

如果必须保证 Windows 重读 FAT，可以在测速完成后：
```c
ux_device_stack_disconnect();  // 断开 USB
tx_thread_sleep(500);          // 等待
USBX_MSC_Resume();              // 重新注册
HAL_PCD_Start(...);             // 重新连接
```

先测试当前修改。如果还是 `G:?`，再考虑方案 4。

```c
ux_device_stack_disconnect();  // 断开 USB
tx_thread_sleep(500);          // 等待
USBX_MSC_Resume();              // 重新注册
HAL_PCD_Start(...);             // 重新连接
```

---

**User**

已经修改了，延迟事件 100tick 改为 5000 tick（5秒）之后还是会变成 G:?

---

**Cursor**


延迟 + UNIT ATTENTION 仍出现 `G:?`，说明 Windows 的 FAT 缓存与磁盘不一致，仅靠 SCSI sense 无法强制刷新。需要强制 Windows 重新枚举 MSC。

采用方案 4：在测速完成后断开并重新连接 USB，让 Windows 完全重新枚举。



延迟 + UNIT ATTENTION 仍出现 `G:?`，说明 Windows 的 FAT 缓存很顽固。建议采用更可靠的方法：在测速完成后强制断开并重新连接 USB，让 Windows 完全重新枚举 MSC。



提供一个强制重新枚举的方案：在测速完成后，短暂断开 USB 并重新连接，让 Windows 完全重新枚举 MSC。CDC 会短暂断开，但通常会自动恢复。


```c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    app_usbx_device.c
  * @author  MCD Application Team
  * @brief   USBX Device applicative file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2020-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/* Includes ------------------------------------------------------------------*/
#include "app_usbx_device.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "usb_otg.h"
#include "ux_dcd_stm32.h"
#include "ux_device_msc.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

static ULONG storage_interface_number;
static ULONG storage_configuration_number;
static ULONG cdc_acm_interface_number;
static ULONG cdc_acm_configuration_number;
static UX_SLAVE_CLASS_STORAGE_PARAMETER storage_parameter;
static UX_SLAVE_CLASS_CDC_ACM_PARAMETER cdc_acm_parameter;
static TX_THREAD ux_device_app_thread;

/* USER CODE BEGIN PV */
/* 事件标志组 */
TX_EVENT_FLAGS_GROUP EventFlagMsc;         //!< MSC     事件标志组
TX_EVENT_FLAGS_GROUP EventFlagCdcAcm;      //!< CDC ACM 事件标志组

/* 线程控制块 */
static TX_THREAD ux_cdc_acm_thread;            //!< CDC ACM 线程控制块
static TX_THREAD ux_cdc_acm_cmd_parse_thread;  //!< CDC ACM 命令拆包解析线程控制块

/* 参数绑定 */
UX_SLAVE_CLASS_CDC_ACM_CALLBACK_PARAMETER cdc_acm_callback_parameter; //!< 参数绑定 CDC ACM 回调函数

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
static VOID app_ux_device_thread_entry(ULONG thread_input);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/**
  * @brief  Application USBX Device Initialization.
  * @param  memory_ptr: memory pointer
  * @retval status
  */
UINT MX_USBX_Device_Init(VOID *memory_ptr)
{
  UINT ret = UX_SUCCESS;
  UCHAR *device_framework_high_speed;
  UCHAR *device_framework_full_speed;
  ULONG device_framework_hs_length;
  ULONG device_framework_fs_length;
  ULONG string_framework_length;
  ULONG language_id_framework_length;
  UCHAR *string_framework;
  UCHAR *language_id_framework;
  UCHAR *pointer;
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;

  /* USER CODE BEGIN MX_USBX_Device_Init0 */

  /* USER CODE END MX_USBX_Device_Init0 */

  /* Allocate the stack for USBX Memory */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer,
                       USBX_DEVICE_MEMORY_STACK_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_ALLOCATE_STACK_ERROR */
    return TX_POOL_ERROR;
    /* USER CODE END USBX_ALLOCATE_STACK_ERROR */
  }

  /* Initialize USBX Memory */
  if (ux_system_initialize(pointer, USBX_DEVICE_MEMORY_STACK_SIZE, UX_NULL, 0) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_SYSTEM_INITIALIZE_ERROR */
    return UX_ERROR;
    /* USER CODE END USBX_SYSTEM_INITIALIZE_ERROR */
  }

  /* Get Device Framework High Speed and get the length */
  device_framework_high_speed = USBD_Get_Device_Framework_Speed(USBD_HIGH_SPEED,
                                                                &device_framework_hs_length);

  /* Get Device Framework Full Speed and get the length */
  device_framework_full_speed = USBD_Get_Device_Framework_Speed(USBD_FULL_SPEED,
                                                                &device_framework_fs_length);

  /* Get String Framework and get the length */
  string_framework = USBD_Get_String_Framework(&string_framework_length);

  /* Get Language Id Framework and get the length */
  language_id_framework = USBD_Get_Language_Id_Framework(&language_id_framework_length);

  /* Install the device portion of USBX */
  if (ux_device_stack_initialize(device_framework_high_speed,
                                 device_framework_hs_length,
                                 device_framework_full_speed,
                                 device_framework_fs_length,
                                 string_framework,
                                 string_framework_length,
                                 language_id_framework,
                                 language_id_framework_length,
                                 UX_NULL) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_INITIALIZE_ERROR */
    return UX_ERROR;
    /* USER CODE END USBX_DEVICE_INITIALIZE_ERROR */
  }

  /* Initialize the storage class parameters for the device */
  storage_parameter.ux_slave_class_storage_instance_activate   = USBD_STORAGE_Activate;
  storage_parameter.ux_slave_class_storage_instance_deactivate = USBD_STORAGE_Deactivate;

  /* Store the number of LUN in this device storage instance */
  storage_parameter.ux_slave_class_storage_parameter_number_lun = STORAGE_NUMBER_LUN;

  /* Initialize the storage class parameters for reading/writing to the Flash Disk */
  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_last_lba = USBD_STORAGE_GetMediaLastLba();

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_block_length = USBD_STORAGE_GetMediaBlocklength();

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_type = 0;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_removable_flag = STORAGE_REMOVABLE_FLAG;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_read_only_flag = STORAGE_READ_ONLY;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_read = USBD_STORAGE_Read;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_write = USBD_STORAGE_Write;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_flush = USBD_STORAGE_Flush;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_status = USBD_STORAGE_Status;

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_notification = USBD_STORAGE_Notification;

  /* USER CODE BEGIN STORAGE_PARAMETER */
  // 用户自定义MSC类的参数绑定代码
  /* USER CODE END STORAGE_PARAMETER */

  /* Get storage configuration number */
  storage_configuration_number = USBD_Get_Configuration_Number(CLASS_TYPE_MSC, 0);

  /* Find storage interface number */
  storage_interface_number = USBD_Get_Interface_Number(CLASS_TYPE_MSC, 0);

  /* Initialize the device storage class */
  if (ux_device_stack_class_register(_ux_system_slave_class_storage_name,
                                     ux_device_class_storage_entry,
                                     storage_configuration_number,
                                     storage_interface_number,
                                     &storage_parameter) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_STORAGE_REGISTER_ERROR */
    return UX_ERROR;
    /* USER CODE END USBX_DEVICE_STORAGE_REGISTER_ERROR */
  }

  /* Initialize the cdc acm class parameters for the device */
  cdc_acm_parameter.ux_slave_class_cdc_acm_instance_activate   = USBD_CDC_ACM_Activate;
  cdc_acm_parameter.ux_slave_class_cdc_acm_instance_deactivate = USBD_CDC_ACM_Deactivate;
  cdc_acm_parameter.ux_slave_class_cdc_acm_parameter_change    = USBD_CDC_ACM_ParameterChange;

  /* USER CODE BEGIN CDC_ACM_PARAMETER */
  /* 用户自定义CDC类的参数绑定代码 */

  // 绑定 USB CDC ACM 收发中断回调函数
  cdc_acm_callback_parameter.ux_device_class_cdc_acm_parameter_read_callback = USBD_CDC_ACM_Read_Callback;
  cdc_acm_callback_parameter.ux_device_class_cdc_acm_parameter_write_callback = USBD_CDC_ACM_Write_Callback;

  /* ux_device_class_cdc_acm_ioctl(cdc_acm, UX_SLAVE_CLASS_CDC_ACM_IOCTL_TRANSMISSION_START, &cdc_acm_callback_parameter);
   * ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~
   * 这之后，需要执行启动带回调的传输功能 IOCTL 命令，需在 USBD_CDC_ACM_Activate() 中执行，
   * 因为当 USB 设备枚举完成，由 USBX 调用激活回调函数 USBD_CDC_ACM_Activate() 时， cdc_acm 实例才创建并初始化
   */

  /* USER CODE END CDC_ACM_PARAMETER */

  /* Get cdc acm configuration number */
  cdc_acm_configuration_number = USBD_Get_Configuration_Number(CLASS_TYPE_CDC_ACM, 0);

  /* Find cdc acm interface number */
  cdc_acm_interface_number = USBD_Get_Interface_Number(CLASS_TYPE_CDC_ACM, 0);

  /* Initialize the device cdc acm class */
  if (ux_device_stack_class_register(_ux_system_slave_class_cdc_acm_name,
                                     ux_device_class_cdc_acm_entry,
                                     cdc_acm_configuration_number,
                                     cdc_acm_interface_number,
                                     &cdc_acm_parameter) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_CDC_ACM_REGISTER_ERROR */
    return UX_ERROR;
    /* USER CODE END USBX_DEVICE_CDC_ACM_REGISTER_ERROR */
  }

  /* Allocate the stack for device application main thread */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, UX_DEVICE_APP_THREAD_STACK_SIZE,
                       TX_NO_WAIT) != TX_SUCCESS)
  {
    /* USER CODE BEGIN MAIN_THREAD_ALLOCATE_STACK_ERROR */
    return TX_POOL_ERROR;
    /* USER CODE END MAIN_THREAD_ALLOCATE_STACK_ERROR */
  }

  /* Create the device application main thread */
  if (tx_thread_create(&ux_device_app_thread, UX_DEVICE_APP_THREAD_NAME, app_ux_device_thread_entry,
                       0, pointer, UX_DEVICE_APP_THREAD_STACK_SIZE, UX_DEVICE_APP_THREAD_PRIO,
                       UX_DEVICE_APP_THREAD_PREEMPTION_THRESHOLD, UX_DEVICE_APP_THREAD_TIME_SLICE,
                       UX_DEVICE_APP_THREAD_START_OPTION) != TX_SUCCESS)
  {
    /* USER CODE BEGIN MAIN_THREAD_CREATE_ERROR */
    return TX_THREAD_ERROR;
    /* USER CODE END MAIN_THREAD_CREATE_ERROR */
  }

  /* USER CODE BEGIN MX_USBX_Device_Init1 */
  /* 初始化 CDC 监视线程 */
  /* Allocate the stack for usbx cdc acm thread */
  ret = tx_byte_allocate(byte_pool, (VOID **) &pointer, UX_DEVICE_APP_THREAD_STACK_SIZE, TX_NO_WAIT);
  if (ret != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }
  /* Create the usbx_cdc_acm_thread_entry thread */
  ret = tx_thread_create(&ux_cdc_acm_thread, "cdc_acm_usbx_app_thread_entry",
          usbx_cdc_acm_thread_entry, 1, pointer,
          UX_DEVICE_APP_THREAD_STACK_SIZE, 20, 20, TX_NO_TIME_SLICE,
          TX_AUTO_START);
  if (ret != TX_SUCCESS)
  {
	return TX_THREAD_ERROR;
  }

  /* 初始化 CDC 命令拆包解析线程 */
  /* Allocate the stack for usbx cdc acm test thread */
  ret = tx_byte_allocate(byte_pool, (VOID **) &pointer, UX_DEVICE_APP_THREAD_STACK_SIZE, TX_NO_WAIT);
  if (ret != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }
  /* Create the usbx_cdc_acm_thread_entry thread */
  ret = tx_thread_create(&ux_cdc_acm_cmd_parse_thread, "cdc_acm_cmd_parse_thread_entry",
		  usbx_cdc_acm_cmd_parse_thread_entry, 1, pointer,
          UX_DEVICE_APP_THREAD_STACK_SIZE, 20, 20, TX_NO_TIME_SLICE,
          TX_AUTO_START);
  if (ret != TX_SUCCESS)
  {
	return TX_THREAD_ERROR;
  }

  /* 初始化 MSC 变量*/
  ret = USBD_STORAGE_Pre_Init();
  if (ret != TX_SUCCESS)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  /* 初始化 CDC 变量 */
  ret = USBD_CDC_ACM_Pre_Init();
  if (ret != TX_SUCCESS)
  {
	  _Error_Handler(__FILE__, __LINE__);
  }

  /* USER CODE END MX_USBX_Device_Init1 */

  return ret;
}

/**
  * @brief  Function implementing app_ux_device_thread_entry.
  * @param  thread_input: User thread input parameter.
  * @retval none
  */
static VOID app_ux_device_thread_entry(ULONG thread_input)
{
  /* USER CODE BEGIN app_ux_device_thread_entry */
  TX_PARAMETER_NOT_USED(thread_input);

  /* Initialization of USB device */
  USBX_APP_Device_Init();

  /* USER CODE END app_ux_device_thread_entry */
}

/* USER CODE BEGIN 2 */

/**
  * @brief  USBX_APP_Device_Init
  *         Initialization of USB device.
  * @param  none
  * @retval none
  */
VOID USBX_APP_Device_Init(VOID)
{
  /* USER CODE BEGIN USB_Device_Init_PreTreatment_0 */

  /* USER CODE END USB_Device_Init_PreTreatment_0 */

  /* USB_OTG_HS init function */
  MX_USB_OTG_HS_PCD_Init();

  /* USER CODE BEGIN USB_Device_Init_PreTreatment_1 */

  /**
   * USB FIFO 配置
   *   最大FIFO合计容量 0x1000 字，当前大小合计：0x412 字
   * 开启USB DMA后，FIFO 要留有余量
   *   https://forum.anfulai.cn/forum.php?mod=viewthread&tid=109916&highlight=USB%2BHS
   *   默认0x200参数过大，但修改为0x80小了也无响应，
   *   修改为0x180后DMA传输正常，1000个获取浮点数都能相应
   *   每个FIFO需要分配 24Btye DMA 描述符，三个FiFo需要72Byte，
   *   则能分配收发缓冲区最大为4096-72=4024Byte
   *
   * 通过CubeMX生成的宏配置端点FIFO大小：https://community.st.com/t5/stm32-mcus-products/nucleo-u5a5zj-q-usb-cdc-acm-issue-with-ux-device-class-cdc-acm/td-p/632086
   */
  // MSC 端点 FIFO 配置参考：案例 3：大容量存储：https://community.st.com/t5/stm32-mcus/practical-use-cases-to-manage-fifo-in-usb-otg-controllers-in/ta-p/839963
  /* Set Rx FIFO to accommodate 512 words*/
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_HS, 0x200);                             //!<           大小：0x200 字：RX FIFO

  /* Set Tx FIFO 0 size to 16 words (64 bytes) for Control IN endpoint (EP0). */
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 0, USBD_MAX_EP0_SIZE / 4);          //!< 端点号0 ：大小：0x10  字：IN 控制端点 FIFO
  
  /* Set Tx FIFO 1 to 256 words (1KB) for Bulk IN endpoint */
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 1, USBD_MSC_EPIN_HS_MPS / 4);       //!< 端点号1 ：大小：0x100 字：MSC_ENDPOINT_IN / OUT FIFO

  // CDC ACM 端点 FIFO 配置参考：https://github.com/STMicroelectronics/x-cube-azrtos-h7/blob/main/Projects/NUCLEO-H723ZG/Applications/USBX/Ux_Device_CDC_ACM/USBX/App/app_usbx_device.c
  /* Set Tx FIFO 2 */
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 2, USBD_CDCACM_EPINCMD_HS_MPS / 4); //!< 端点号2： 大小：0x2   字：CDC ACM CMD FIFO

  /* Set Tx FIFO 3 */
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 3, USBD_CDCACM_EPIN_HS_MPS / 4);    //!< 端点号3： 大小：0x100 字：CDC ACM BULK FIFO


  /* USER CODE END USB_Device_Init_PreTreatment_1 */

  /* Initialize and link controller HAL driver */
  // 注册STM32 HS 到USBX协议栈并初始化
  ux_dcd_stm32_initialize((ULONG)USB_OTG_HS, (ULONG)&hpcd_USB_OTG_HS);

  /* Start USB device */
  HAL_PCD_Start(&hpcd_USB_OTG_HS);

  /* USER CODE BEGIN USB_Device_Init_PostTreatment */

  /* USER CODE END USB_Device_Init_PostTreatment */
}

UINT USBD_STORAGE_Pre_Init(VOID)
{
    UINT ret;

    /* 首次启动 USBX MSC    初始化事件标志组 */
    ret = tx_event_flags_create(&EventFlagMsc, "Event MSC Flag");
    if (ret != TX_SUCCESS)
    {
      _Error_Handler(__FILE__, __LINE__);
    }
    return ret;
}


UINT USBX_MSC_Pause(VOID)
{
    UINT status = UX_SUCCESS;

    status = ux_device_stack_class_unregister(_ux_system_slave_class_storage_name,
                                              ux_device_class_storage_entry);

    return status;
}

UINT USBX_MSC_Resume(VOID)
{
    UINT status = UX_SUCCESS;

    status = ux_device_stack_class_register(_ux_system_slave_class_storage_name,
                                            ux_device_class_storage_entry,
                                            storage_configuration_number,
                                            storage_interface_number,
                                            &storage_parameter);

    return status;
}

/**
  * @brief  强制重新枚举 USB 设备（断开并重新连接）
  *         注意：这会导致 CDC 也短暂断开，但会自动恢复
  */
VOID USBX_Force_Reconnect(VOID)
{
    extern PCD_HandleTypeDef hpcd_USB_OTG_HS;
    
    /* 停止 USB 设备 */
    HAL_PCD_Stop(&hpcd_USB_OTG_HS);
    
    /* 等待主机检测到断开 */
    tx_thread_sleep(200);  // 200 ticks，约 2 秒（假设 1 tick = 10ms）
    
    /* 重新启动 USB 设备 */
    HAL_PCD_Start(&hpcd_USB_OTG_HS);
}

/* USER CODE END 2 */

```

```c
/**
  ******************************************************************************
  * @file        app_demo_sd_filex.c
  * @author      安富莱电子 www.armfly.com
  * @created on  2025年12月3日
  * @brief       
  ******************************************************************************
  * @attention
  *
  * Copyright (C), 2021-2030, 安富莱电子 www.armfly.com
  *
  * @attention
  *           本文件代码片段源于安富莱电子（www.armfly.com）开源示例工程
  *           OldGerman 对其原始文件进行修改后使用
  *
  *	模块名称 : SD卡Fat文件系统和SD卡模拟演示模块。
  *	文件名称 : demo_sd_filex.c
  *	版    本 : V1.0
  *	说    明 : 演示如何创建文件、读取文件、创建目录和删除文件
  *			   并测试了文件读写速度.支持以下6个功能，用户通过电脑端
  *			   串口软件发送数字给开发板即可:
  *              1 - 显示根目录下的文件列表
  *              2 - 创建一个新文件armfly.txt
  *              3 - 读armfly.txt文件的内容
  *              4 - 创建目录
  *              5 - 删除文件和目录
  *              6 - 读写文件速度测试
  *              a - 打开SD卡模拟U盘
  *              b - 关闭SD卡模拟U盘
  *
  * 版    本 : V2.0
  * 说    明 : 将每一个测试函数执行后，变为后台线程只运行一次后结束
  *
  *              另外注意，SD卡模拟U盘是用的MicroUSB接口。
  *	修改记录 :
  *		版本号   日期         作者        说明
  *		V1.0    2021-01-30   Eric2013    正式发布
  *		V2.0    2025-12--3   OldGerman   改为ThreadX单次任务
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
//#include "includes.h"
#include "stdint.h"
#include  <stdarg.h>
#include  <stdio.h>
#include  <stdlib.h>
#include  <math.h>
#include "sdmmc.h"
#include "tx_api.h"
#include "tx_timer.h"
#include "fx_api.h"
#include "app_filex.h"
#include "fx_stm32_sd_driver.h"
#include "app_usbx_device.h"
#include "ux_device_msc.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define bsp_GetRunTime          tx_time_get

/* Private macro -------------------------------------------------------------*/
/* 用于测试读写速度 */
#define TEST_FILE_LEN			(2*1024*1024)	/* 用于测试的文件长度 */
#define BUF_SIZE				(32*1024)		/* 每次读写SD卡的最大数据长度 */

/* Exported constants --------------------------------------------------------*/
/* Private constants ---------------------------------------------------------*/
/* Exported variables --------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* 测试所用静态内存 */
__attribute__((section(".axisram2_bss"), aligned(32)))
uint32_t media_memory[16*1024];
ALIGN_32BYTES (char FsReadBuf[1024]);
ALIGN_32BYTES (char FsWriteBuf[1024]) = {"ThreadX FileX Write Demo \r\n www.armfly.com \r\n"};
//ALIGN_32BYTES (uint8_t g_TestBuf[BUF_SIZE]);
//__attribute__((section(".axisram2_bss"), aligned(32))) char FsReadBuf[1024];
//__attribute__((section(".axisram2_data"), aligned(32), used)) char FsWriteBuf[1024] = {"ThreadX FileX Write Demo \r\n www.armfly.com \r\n"};
//__attribute__((section(".axisram2_bss"), aligned(32))) uint8_t g_TestBuf[BUF_SIZE];
__attribute__((section(".sram1_bss"), aligned(32))) uint8_t g_TestBuf[BUF_SIZE];

/* FileX相关变量 */
FX_FILE      fx_file;
CHAR         entry_name[FX_MAX_LONG_NAME_LEN];

/* Private function prototypes -----------------------------------------------*/
static void DispMenu(void);
static void ViewRootDir(void);
static void CreateNewFile(void);
static void ReadFileData(void);
static void CreateDir(void);
static void DeleteDirFile(void);
void fxSdTestSpeed(void);

/* Function implementations --------------------------------------------------*/



/*
*********************************************************************************************************
*	函 数 名: DemoFatFS
*	功能说明: FatFS文件系统演示主程序
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/

void DemoFileX(void)
{
  fxSdTestSpeed();
//switch()
//	case'0':
//	DispMenu();
//	break;
//	case '1':
//	printf("【1 - ViewRootDir】\r\n");
//	ViewRootDir();		/* 显示SD卡根目录下的文件名 */
//	break;
//
//	case '2':
//	printf("【2 - CreateNewFile】\r\n");
//	CreateNewFile();	/* 创建一个新文件,写入一个字符串 */
//	break;
//
//	case '3':
//	printf("【3 - ReadFileData】\r\n");
//	ReadFileData();		/* 读取根目录下armfly.txt的内容 */
//	break;
//
//	case '4':
//	printf("【4 - CreateDir】\r\n");
//	CreateDir();		/* 创建目录 */
//	break;
//
//	case '5':
//	printf("【5 - DeleteDirFile】\r\n");
//	DeleteDirFile();	/* 删除目录和文件 */
//	break;
//
//	case '6':
//	printf("【6 - TestSpeed】\r\n");
//	WriteFileTest();	/* 速度测试 */
//	break;
//
//	default:
//
//	break;
}

/*
*********************************************************************************************************
*	函 数 名: DispMenu
*	功能说明: 显示操作提示菜单
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void DispMenu(void)
{
	printf("\r\n------------------------------------------------\r\n");
	printf("请选择操作命令，打开SD卡模拟U盘操作期间不支持再调用命令1-6:\r\n");
	printf("1 - 显示根目录下的文件列表\r\n");
	printf("2 - 创建一个新文件armfly.txt\r\n");
	printf("3 - 读armfly.txt文件的内容\r\n");
	printf("4 - 创建目录\r\n");
	printf("5 - 删除文件和目录\r\n");
	printf("6 - 读写文件速度测试\r\n");
}

/*
*********************************************************************************************************
*	函 数 名: ViewRootDir
*	功能说明: 显示SD卡根目录下的文件名
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
extern SD_HandleTypeDef hsd2;
static void ViewRootDir(void)
{
    UINT status;
    UINT attributes;
    ULONG size;
    UINT year;
    UINT month;
    UINT day;
    UINT hour;
    UINT minute;
    UINT second;
    UINT cnt;
    ULONG64 available_bytes;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }


    printf("属性        |  文件大小 | 短文件名 | 长文件名\r\n");
	for (cnt = 0; ;cnt++)
	{
        /* 读取目录项，索引会自动下移 */
        status = fx_directory_next_full_entry_find(&sdio_disk,
                                                    entry_name,
                                                    &attributes,
                                                    &size,
                                                    &year, &month, &day,
                                                    &hour, &minute, &second);

        if (status != FX_SUCCESS || entry_name[0] == 0)
		{
			break;
		}

		if (entry_name[0] == '.')
		{
			continue;
		}

		/* 判断是文件还是子目录 */
		if (attributes & FX_DIRECTORY)
		{
			printf("目录  ");
		}
		else
		{
			printf("文件  ");
		}

		/* 打印文件大小, 最大4G */
		printf(" %10d", (int)size);


		printf("  %s\r\n", (char *)entry_name);	/* 长文件名 */
	}

    /* SD卡剩余容量大小 */
    status = fx_media_extended_space_available(&sdio_disk, &available_bytes);

    if (status == FX_SUCCESS)
    {
        printf("SD卡剩余容量大小 -- %lldMB\r\n", available_bytes/1024/1024);
    }

    /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: CreateNewFile
*	功能说明: 在SD卡创建一个新文件，文件内容填写“www.armfly.com”
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void CreateNewFile(void)
{
    UINT status;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 创建文件 */
    status =  fx_file_create(&sdio_disk, "armfly.txt");

    /* 检测状态 */
    if (status != FX_SUCCESS)
    {
        /* 失败的话，可以考虑二次创建 */
        if (status != FX_ALREADY_CREATED)
        {
            printf("创建文件失败\r\n");
        }
    }

    /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, "armfly.txt", FX_OPEN_FOR_WRITE);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }


    /* 写入字符串到文件  */
    status =  fx_file_write(&fx_file, FsWriteBuf, strlen(FsWriteBuf));

    if (status == FX_SUCCESS)
    {
        printf("armfly.txt 文件写入成功\r\n");
    }
    else
    {
        printf("armfly.txt 文件写入失败 %d\r\n", status);
    }

    /* 关闭文件  */
    status =  fx_file_close(&fx_file);

    /* Check the file close status.  */
    if (status != FX_SUCCESS)
    {
        printf("关闭文件失败\r\n");
    }

    /* 保证文件写入全部生效 */
    status = fx_media_flush(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("flush失败\r\n");
    }

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: ReadFileData
*	功能说明: 读取文件armfly.txt前128个字符，并打印到串口
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ReadFileData(void)
{
    UINT status;
    ULONG bw;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }


    /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, "armfly.txt", FX_OPEN_FOR_READ);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }

    /*  */
    status =  fx_file_read(&fx_file, FsReadBuf, sizeof(FsReadBuf), &bw);

    printf("--%sReadLen = %d\r\n", FsReadBuf, (int)bw);

    if ((status != FX_SUCCESS))
    {
        printf("读取失败\r\n");
    }

    /* 关闭文件  */
    status =  fx_file_close(&fx_file);

    if (status != FX_SUCCESS)
    {
        printf("关闭文件失败\r\n");
    }

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: CreateDir
*	功能说明: 在SD卡根目录创建Dir1和Dir2目录，在Dir1目录下创建子目录Dir1_1
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void CreateDir(void)
{
    UINT status;


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 创建目录/Dir1 */
    status = fx_directory_create(&sdio_disk, "Dir1");

    if (status == FX_SUCCESS)
    {
        printf("文件夹Dir1创建成功\r\n");
    }
	else if (status == FX_ALREADY_CREATED)
	{
		printf("Dir1 目录已经存在(%d)\r\n", status);
	}
	else
	{
		printf("fx_directory_create Dir1 失败 (%d)\r\n", status);
		return;
	}

	/* 创建目录/Dir2 */
    status = fx_directory_create(&sdio_disk, "Dir2");

    if (status == FX_SUCCESS)
    {
        printf("文件夹Dir2创建成功\r\n");
    }
	else if (status == FX_ALREADY_CREATED)
	{
		printf("Dir2 目录已经存在(%d)\r\n", status);
	}
	else
	{
		printf("fx_directory_create Dir2 失败 (%d)\r\n", status);
		return;
	}

	/* 创建子目录 /Dir1/Dir1_1	   注意：创建子目录Dir1_1时，必须先创建好Dir1 ？ */
    status = fx_directory_create(&sdio_disk, "Dir1/Dir1_1");

    if (status == FX_SUCCESS)
    {
        printf("文件夹Dir1/Dir1_1创建成功\r\n");
    }
	else if (status == FX_ALREADY_CREATED)
	{
		printf("Dir1/Dir1_1 目录已经存在(%d)\r\n", status);
	}
	else
	{
		printf("fx_directory_create Dir1/Dir1_1 失败 (%d)\r\n", status);
		return;
	}

    /* 保证文件写入全部生效 */
    status = fx_media_flush(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("flush失败\r\n");
    }

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}

/*
*********************************************************************************************************
*	函 数 名: DeleteDirFile
*	功能说明: 删除SD卡根目录下的 armfly.txt 文件和 Dir1，Dir2 目录
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
static void DeleteDirFile(void)
{
    UINT status;
    UINT i;
    char path[50];


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 删除目录/Dir1 【因为还存在目录非空（存在子目录)，所以这次删除会失败】*/
    status = fx_directory_delete(&sdio_disk, "Dir1");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir1成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "/Dir1");
	}
	else
	{
		printf("删除Dir1失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}


 	/* 先删除目录/Dir1/Dir1_1 */
    status = fx_directory_delete(&sdio_disk, "Dir1/Dir1_1");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir1/Dir1_1成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "Dir1/Dir1_1");
	}
	else
	{
		printf("删除Dir1/Dir1_1失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

    /* 删除目录/Dir1*/
    status = fx_directory_delete(&sdio_disk, "Dir1");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir1成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "Dir1");
	}
	else
	{
		printf("删除Dir1失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

    /* 删除目录/Dir2*/
    status = fx_directory_delete(&sdio_disk, "Dir2");

    if (status == FX_SUCCESS)
	{
		printf("删除目录Dir2成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "Dir2");
	}
	else
	{
		printf("删除Dir2失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

	/* 删除文件 armfly.txt */
    status = fx_file_delete(&sdio_disk, "armfly.txt");

    if (status == FX_SUCCESS)
	{
		printf("删除目录armfly.txt成功\r\n");
	}
	else if (status == FX_NOT_FOUND)
	{
		printf("没有发现文件或目录 :%s\r\n", "armfly.txt");
	}
	else
	{
		printf("删除armfly.txt失败(错误代码 = %d) 文件只读或目录非空\r\n", status);
	}

	/* 删除文件 speed1.txt */
	for (i = 0; i < 20; i++)
	{
		sprintf(path, "Speed%02d.txt", i);/* 每写1次，序号递增 */

        status = fx_file_delete(&sdio_disk, path);

        if (status == FX_SUCCESS)
        {
            printf("删除文件%s成功\r\n", path);
        }
        else if (status == FX_NOT_FOUND)
        {
            printf("没有发现文件:%s\r\n", path);
        }
        else
        {
            printf("删除%s文件失败(错误代码 = %d) 文件只读或目录非空\r\n", path, status);
        }
	}

     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }
}


/*
*********************************************************************************************************
*	函 数 名: WriteFileTest
*	功能说明: 测试文件读写速度
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void fxSdTestSpeed(void)
{
    UINT status;
    char path[64];

    ULONG bw;
	uint32_t i,k;
	uint32_t runtime1,runtime2,timelen;
	uint8_t err = 0;
	static uint8_t s_ucTestSn = 0;

	g_media_present = UX_FALSE; // PC 先弹出 U盘:
//	status = USBX_MSC_Pause();

	for (i = 0; i < sizeof(g_TestBuf); i++)
	{
		g_TestBuf[i] = (i / 512) + '0';
	}


    /* 挂载SD卡 */
    status =  fx_media_open(&sdio_disk, "STM32_SDIO_DISK", fx_stm32_sd_driver, 0, media_memory, sizeof(media_memory));

    if (status != FX_SUCCESS)
    {
        printf("挂载文件系统失败 -- %d\r\n", status);
        return;
    }

    /* 打开文件 */
	sprintf(path, "Speed%02d.txt", s_ucTestSn++); /* 每写1次，序号递增 */

    /* 写一串数据 */
	printf("开始写文件%s %dKB ...\r\n", path, TEST_FILE_LEN / 1024);

    /* 创建文件 */
    status =  fx_file_create(&sdio_disk, path);

    /* 检测状态 */
    if (status != FX_SUCCESS)
    {
        /* 失败的话，可以考虑二次创建 */
        if (status != FX_ALREADY_CREATED)
        {
            printf("创建文件失败\r\n");
        }
    }

    /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, path, FX_OPEN_FOR_WRITE);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }

    runtime1 = bsp_GetRunTime();	/* 读取系统运行时间 */
    for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
	{
        /* 写入字符串到文件  */
        status =  fx_file_write(&fx_file, g_TestBuf, sizeof(g_TestBuf));

        if (status == FX_SUCCESS)
        {
            if (((i + 1) % 8) == 0)
			{
				printf(".");
			}
        }
        else
        {
            err = 1;
			printf("%s文件写失败\r\n", path);
			break;
        }
	}
	runtime2 = bsp_GetRunTime();	/* 读取系统运行时间 */

	if (err == 0)
	{
		timelen = (runtime2 - runtime1);
		printf("\r\n  写耗时 : %ldms   平均写速度 : %ldB/S (%ldKB/S)\r\n",
                timelen,
                (TEST_FILE_LEN * 1000) / timelen,
                ((TEST_FILE_LEN / 1024) * 1000) / timelen);
		//-Og 4366KB/s@10MHz, 7787KB/s@50MHz
	}

    /* 关闭文件  */
    status =  fx_file_close(&fx_file);

    /* Check the file close status.  */
    if (status != FX_SUCCESS)
    {
        printf("关闭文件失败\r\n");
    }

    /* 保证文件写入全部生效 */
    status = fx_media_flush(&sdio_disk);

    /* Check the file close status.  */
    if (status != FX_SUCCESS)
    {
        printf("fx_media_flush失败\r\n");
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////
    /* 开始读文件测试 */
	printf("开始读文件 %dKB ...\r\n", TEST_FILE_LEN / 1024);

      /* 打开文件  */
    status =  fx_file_open(&sdio_disk, &fx_file, path, FX_OPEN_FOR_READ);

    if (status != FX_SUCCESS)
    {
        printf("打开文件失败\r\n");
    }

    /* 设置到起始位置读取  */
    status =  fx_file_seek(&fx_file, 0);

    if (status != FX_SUCCESS)
    {
        printf("设置读取位置失败\r\n");
    }

    runtime1 = bsp_GetRunTime();	/* 读取系统运行时间 */
    for (i = 0; i < TEST_FILE_LEN / BUF_SIZE; i++)
	{
        /* 写入字符串到文件  */

        status =  fx_file_read(&fx_file, g_TestBuf, sizeof(g_TestBuf), &bw);
        if (status == FX_SUCCESS)
        {
        	if (((i + 1) % 8) == 0)
			{
				printf(".");
			}

			/* 比较写入的数据是否正确，此语句会导致读卡速度结果降低到 3.5MBytes/S */
			for (k = 0; k < sizeof(g_TestBuf); k++)
			{
				if (g_TestBuf[k] != (k / 512) + '0')
				{
				  	err = 1;
					printf("Speed1.txt 文件读成功，但是数据出错\r\n");
					break;
				}
			}
			if (err == 1)
			{
				break;
			}
        }
        else
        {
           	err = 1;
			printf("Speed1.txt 文件读失败\r\n");
			break;
        }
	}
	runtime2 = bsp_GetRunTime();	/* 读取系统运行时间 */

	if (err == 0)
	{
		timelen = (runtime2 - runtime1);
		printf("\r\n  读耗时 : %ldms   平均读速度 : %ldB/S (%ldKB/S)\r\n", timelen,
			(TEST_FILE_LEN * 1000) / timelen, ((TEST_FILE_LEN / 1024) * 1000) / timelen);
		//-Og 6.965KB/s@50MHz
	}

	/**
	 * 不能直接卸载SD卡，会导致USBX MSC无法访问SD卡
	 * https://forum.anfulai.cn/forum.php?mod=redirect&goto=findpost&ptid=124988&pid=311741&fromuid=47676
	 * 找到原因了，原有例程上面是直接卸载了SD卡，我注释掉之后应该要加上fx_file_close
	 */
     /* 卸载SD卡 */
    status =  fx_media_close(&sdio_disk);
//    status =  fx_file_close(&fx_file);

    if (status != FX_SUCCESS)
    {
        printf("卸载文件系统卸载失败 -- %d\r\n", status);
    }

    // 强制重新枚举 USB，让 Windows 完全重新读取 FAT
    printf("强制重新枚举 USB 设备...\r\n");
    USBX_Force_Reconnect();  // 这会断开并重新连接 USB，CDC 会短暂断开但会自动恢复
    
    // 重新注册 MSC
    status = USBX_MSC_Resume();
    if (status != UX_SUCCESS)
    {
        printf("重新注册 MSC 失败 -- %d\r\n", status);
    }
    
    g_media_present = UX_TRUE; // 重新让电脑识别U盘
    g_media_changed = UX_FALSE; // 不需要 UNIT ATTENTION，因为已经重新枚举了
    printf("测速完毕，USB 设备已重新枚举...\r\n");
}

/***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/


```

```cpp
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    app_usbx_device.h
  * @author  MCD Application Team
  * @brief   USBX Device applicative header file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2020-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __APP_USBX_DEVICE_H__
#define __APP_USBX_DEVICE_H__

#ifdef __cplusplus
extern "C" {
#endif

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/* Includes ------------------------------------------------------------------*/
#include "ux_api.h"
#include "ux_device_descriptors.h"
#include "ux_device_msc.h"
#include "ux_device_cdc_acm.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "tx_api.h"
#include "ux_device_class_cdc_acm.h"
/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */
/**
 * 启用CDC ACM 非阻塞传输，必须禁用 UX_DEVICE_CLASS_CDC_ACM_TRANSMISSION_DISABLE，并且需要在 USBX 字节池和 USBX_MEMORY_SIZE 中添加 2048 个额外字节。
 * USBX_MEMORY_SIZE 就是 USBX_DEVICE_MEMORY_STACK_SIZE：
 * https://github.com/STMicroelectronics/STM32CubeH5/blob/188d908ee29667daf0ec2f1dd40bfc2e91389e5e/Projects/STM32H573I-DK/Applications/OpenBootloader/USBX/App/app_usbx_device.c#L25
 *   ↓ USBX_DEVICE_MEMORY_STACK_SIZE 30KB不够用，卡住在 ux_device_stack_class_register(_ux_system_slave_class_cdc_acm_name,
 *   ↓ 改为40K够用！
 */

/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
#define USBX_DEVICE_MEMORY_STACK_SIZE       1024*40

#define UX_DEVICE_APP_THREAD_STACK_SIZE   4096
#define UX_DEVICE_APP_THREAD_PRIO         10

/* USER CODE BEGIN EC */

/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

/* Exported functions prototypes ---------------------------------------------*/
UINT MX_USBX_Device_Init(VOID *memory_ptr);

/* USER CODE BEGIN EFP */
VOID USBX_APP_Device_Init(VOID);
UINT USBX_MSC_Pause(VOID);
UINT USBX_MSC_Resume(VOID);
VOID USBX_Force_Reconnect(VOID);
/* USER CODE END EFP */

/* Private defines -----------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

#ifndef UX_DEVICE_APP_THREAD_NAME
#define UX_DEVICE_APP_THREAD_NAME  "USBX Device App Main Thread"
#endif

#ifndef UX_DEVICE_APP_THREAD_PREEMPTION_THRESHOLD
#define UX_DEVICE_APP_THREAD_PREEMPTION_THRESHOLD  UX_DEVICE_APP_THREAD_PRIO
#endif

#ifndef UX_DEVICE_APP_THREAD_TIME_SLICE
#define UX_DEVICE_APP_THREAD_TIME_SLICE  TX_NO_TIME_SLICE
#endif

#ifndef UX_DEVICE_APP_THREAD_START_OPTION
#define UX_DEVICE_APP_THREAD_START_OPTION  TX_AUTO_START
#endif

/* USER CODE BEGIN 2 */
/* Exported variables --------------------------------------------------------*/
extern TX_EVENT_FLAGS_GROUP EventFlagMsc;
extern TX_EVENT_FLAGS_GROUP EventFlagCdcAcm;
extern UX_SLAVE_CLASS_CDC_ACM_CALLBACK_PARAMETER cdc_acm_callback_parameter;

/* USER CODE END 2 */

#ifdef __cplusplus
}
#endif
#endif /* __APP_USBX_DEVICE_H__ */

```


已添加强制重新枚举 USB 的方案。修改如下：

1. **在 `app_usbx_device.c` 中添加 `USBX_Force_Reconnect()` 函数**：停止 USB PCD，等待约 2 秒，然后重新启动，让 Windows 检测到设备断开并重新连接。

2. **在 `app_demo_sd_filex.c` 中调用该函数**：测速完成后，调用 `USBX_Force_Reconnect()` 强制重新枚举，然后重新注册 MSC。

3. **在头文件中声明函数**：在 `app_usbx_device.h` 中添加函数声明。

**注意**：
- 这会短暂断开 USB（包括 CDC），但通常会自动恢复。
- Windows 会完全重新枚举 MSC，重新读取 FAT，不会出现 `G:?`。
- 如果 CDC 恢复有问题，可以调整延迟时间或添加重连逻辑。

请测试该方案。如果 CDC 恢复有问题，我可以帮你优化重连逻辑。

---

**User**

我已经采纳了你的全部修改，目前测测试读写 @APP/app_demo_sd_filex.c:845 之后，U盘和CDC都会断开，之后windows资源管理器卡死白屏一段时间后，显示U盘是G:?不可访问，CDC也无法访问

You've hit your usage limit

Get Cursor Pro for more Agent usage, unlimited Tab, and more.
